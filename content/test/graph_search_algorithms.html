
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Graph Search &#8212; AI Search Algorithms for Smart Mobility</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.5f77b4aec8189eecf79907ce328c390d.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/tabs.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="https://unpkg.com/thebe@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
      <img src="../../_static/book.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">AI Search Algorithms for Smart Mobility</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../GettingStarted.html">
   Getting Started
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../IntroductionToGeospatialScience.html">
   Introduction to Geographic Data Science
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../GraphSearchAlgorithms.html">
   Graph Search Algorithms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../TabuSearch.html">
   Tabu Search
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../SimulatedAnnealing.html">
   Simulated Annealing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../GeneticAlgorithms.html">
   Genetic Algorithms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ParticleSwarmOptimization.html">
   Particle Swarm Optimization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../AntColonyOptimization.html">
   Ant Colony Optimization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../PeopleMobilityProblems.html">
   People Mobility Problems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../LogisticsProblems.html">
   Logistics Problems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../InfrastructureProblems.html">
   Infrastructure Problems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ToolsAndPythonLibraries.html">
   Tools and Python Libraries
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Datasets.html">
   Datasets
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/content/test/graph_search_algorithms.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/SmartMobilityAlgorithms/book/release/updated_content?urlpath=tree/content/test/graph_search_algorithms.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <a class="colab-button" href="https://colab.research.google.com/github/SmartMobilityAlgorithms/book/blob/release/updated_content/content/test/graph_search_algorithms.ipynb"><button type="button" class="btn btn-secondary topbarbtn"
                title="Launch Colab" data-toggle="tooltip" data-placement="left"><img class="colab-button-logo"
                    src="../../_static/images/logo_colab.png"
                    alt="Interact on Colab">Colab</button></a>
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   Graph Search
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#breadth-first-search-bfs">
   Breadth-first Search (BFS)
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#depth-first-search-dfs">
   Depth-first Search (DFS)
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#dijkstra-search">
   Dijkstra Search
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hill-climbing">
   Hill Climbing
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#beam-search">
   Beam Search
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-search">
   A* Search
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-heuristic">
     The Heuristic
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bi-directional-search">
   Bi-directional Search
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hierarchical-approaches">
   Hierarchical Approaches
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#highway-hierarchies">
     Highway Hierarchies
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#contraction-hierarchies">
     Contraction Hierarchies
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#contraction">
       Contraction
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h4 nav-item toc-entry">
        <a class="reference internal nav-link" href="#what-order-of-contraction-to-the-nodes-should-i-follow">
         What order of contraction to the nodes should I follow?
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#dijkstra">
       Dijkstra
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#how-to-choose-the-order-of-contraction">
     How to choose the order of contraction
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#calculating-ed">
   Calculating ED
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#dijkstra-from-source">
   Dijkstra From Source
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#dijkstra-from-target">
   Dijkstra From Target
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-pruning">
   The Pruning
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#notes-for-implementation">
   Notes for implementation
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="graph-search">
<h1>Graph Search<a class="headerlink" href="#graph-search" title="Permalink to this headline">¶</a></h1>
<p>A graph is a mathematical way to represent the road network. Graph consists of 3 sets: vertices/nodes, edges and a set representing relations between vertices and edges The graph nodes represent intersections, and the edges represent the roads. A route is a sequence of edges connecting the origin node to the destination node. Search is the systematic examination of states to find a path from the start state to the goal state. Mathematically speaking, a graph can be represented by <span class="math notranslate nohighlight">\(G\)</span> where <span class="math notranslate nohighlight">\(G=(V,E)\)</span>. For the graph <span class="math notranslate nohighlight">\(G\)</span>, <span class="math notranslate nohighlight">\(V\)</span> represents a set of vertices and <span class="math notranslate nohighlight">\(E\)</span> represents a set of edges. Each edge is a tuple <span class="math notranslate nohighlight">\((v,w)\)</span> where <span class="math notranslate nohighlight">\(w\)</span>, <span class="math notranslate nohighlight">\(v \in V\)</span>. Weight can be added as a third component to the edge tuple.</p>
<p>Search algorithms can be broadly classified into deterministic algorithms and stochastic algorithms. In the former, the search algorithm follows a rigorous procedure and its path and values of both design variables and the functions are repeatable. For the same starting point, the algorithm will follow the same path whether you run the program today or tomorrow. In the latter, the algorithm always has some randomness and the solution is not exactly repeatable. Based on the availability of information about the search space (e.g., the distance from the current state to the goal), deterministic search algorithms can be broadly classified into blink/uninformed and informed search.</p>
<img src="images/GraphSearch.png" alt="Search Algorithms" style="float: left; margin-right: 10px;" />
</div>
<div class="section" id="breadth-first-search-bfs">
<h1>Breadth-first Search (BFS)<a class="headerlink" href="#breadth-first-search-bfs" title="Permalink to this headline">¶</a></h1>
<p>Graph traversal refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). BFS is a traversing algorithm where you should start traversing from a selected node (source or starting node) and traverse the graph layerwise thus exploring the neighbour nodes (nodes which are directly connected to source node). You must then move towards the next-level neighbour nodes.</p>
<p><strong>BREADTH-FIRST-SEARCH</strong> ( <em>source</em> , <em>destination</em> ) <strong>return</strong> a route<br />
 <em>frontier</em> ← a <strong>FIFO</strong> initialized with <em>source</em> node<br />
 <em>explored</em> ← <em>empty</em><br />
 <em>found</em> ← <em>False</em><br />
 <strong>while</strong>  <em>frontier</em> <strong>is not</strong> <em>empty</em> <strong>and</strong> <em>found</em> <strong>is</strong> <em>False</em> <strong>do</strong><br />
   <em>node</em> ← <em>frontier</em>.pop()<br />
   <strong>add</strong> <em>node</em> <strong>to</strong> <em>explored</em><br />
   <strong>for</strong> <em>child</em> <strong>in</strong> <em>node</em>.expand() <strong>do</strong><br />
     <strong>if</strong> <em>child</em> <strong>is not in</strong> <em>explored</em> <strong>and</strong> <em>child</em> <strong>is not in</strong> <em>frontier</em>   <strong>then</strong><br />
        <strong>if</strong> <em>child</em> <strong>is</strong> <em>destination</em> <strong>then</strong><br />
          <em>route</em> ← <em>child</em>.route()<br />
          <em>found</em> ← <em>True</em><br />
       <strong>add</strong> <em>child</em> <strong>to</strong> <em>frontier</em><br />
 <strong>return</strong>  <em>route</em></p>
<p>We will be trying to find and visualize the path between Equestrian Statue of Edward VII and Bahen Center of Technology around Toronto University campus using breadth first search</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">osmnx</span> <span class="k">as</span> <span class="nn">ox</span>
<span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">utilities</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
</div>
</div>
<p>Here OSMnx find the largest connected component centered around the <code class="docutils literal notranslate"><span class="pre">location</span> <span class="pre">point</span></code> with specified <code class="docutils literal notranslate"><span class="pre">dist</span></code> on each side (w/n/e/s).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">location_point</span> <span class="o">=</span> <span class="p">(</span><span class="mf">43.661667</span><span class="p">,</span> <span class="o">-</span><span class="mf">79.395</span><span class="p">)</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">graph_from_point</span><span class="p">(</span><span class="n">location_point</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">clean_periphery</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here you need to specify which node from our graph is the source (Equestrian Statue of Edward VII) and which is the destination node (Bahen Center of Technology). You can do so by acquiring the decimal coordinates of the desired node and use <a class="reference external" href="https://osmnx.readthedocs.io/en/stable/osmnx.html#osmnx.distance.get_nearest_node"><code class="docutils literal notranslate"><span class="pre">osmnx.distance.get_nearest_node</span></code></a> method</p>
<p>Using the aforementioned method and found that the osmid of the nodes for destination and source are 389677909, 55808290 respectively</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">highlighted</span> <span class="o">=</span> <span class="p">[</span><span class="mi">389677909</span><span class="p">,</span> <span class="mi">55808290</span><span class="p">]</span>

<span class="c1"># marking both the source and destination node</span>

<span class="n">nc</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">highlighted</span> <span class="k">else</span> <span class="s1">&#39;#336699&#39;</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
<span class="n">ns</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">highlighted</span> <span class="k">else</span> <span class="mi">8</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">plot_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="n">ns</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">nc</span><span class="p">,</span> <span class="n">node_zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph_search_algorithms_9_0.png" src="../../_images/graph_search_algorithms_9_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">draw_map</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">highlight</span> <span class="o">=</span> <span class="n">highlighted</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id": "41347337a99748179cd37d8834db3107", "version_major": 2, "version_minor": 0}
</script></div>
</div>
<p>Each node in our graph is represented as a dictionary with many attributes of no interest to us now, so manipulating them would obfuscate the algorithm jumping through hoops to get only one attribute from the dictionary. <b>so</b> we define class <code class="docutils literal notranslate"><span class="pre">Node</span></code> which only retains the data we need to be able to do searching and traversing, like the parent of the node (the one that produced it from its expansion) and the length of the edge between the parent and the node itself.</p>
<p>Please check its source code in <code class="docutils literal notranslate"><span class="pre">./utilities/src/common.py</span></code> to know how it captures the data from the graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">source</span><span class="p">(</span><span class="n">Node</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<!--
generated by Pygments <https://pygments.org/>
Copyright 2006-2019 by the Pygments team.
Licensed under the BSD license, see LICENSE for details.
-->
<html>
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=None">
  <style type="text/css">
/*
generated by Pygments <https://pygments.org/>
Copyright 2006-2019 by the Pygments team.
Licensed under the BSD license, see LICENSE for details.
*/
td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }
body .hll { background-color: #ffffcc }
body  { background: #f8f8f8; }
body .c { color: #408080; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #008000; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
body .cm { color: #408080; font-style: italic } /* Comment.Multiline */
body .cp { color: #BC7A00 } /* Comment.Preproc */
body .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
body .c1 { color: #408080; font-style: italic } /* Comment.Single */
body .cs { color: #408080; font-style: italic } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
body .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #008000 } /* Keyword.Pseudo */
body .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #B00040 } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BA2121 } /* Literal.String */
body .na { color: #7D9029 } /* Name.Attribute */
body .nb { color: #008000 } /* Name.Builtin */
body .nc { color: #0000FF; font-weight: bold } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #0000FF } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #19177C } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mb { color: #666666 } /* Literal.Number.Bin */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sa { color: #BA2121 } /* Literal.String.Affix */
body .sb { color: #BA2121 } /* Literal.String.Backtick */
body .sc { color: #BA2121 } /* Literal.String.Char */
body .dl { color: #BA2121 } /* Literal.String.Delimiter */
body .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BA2121 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BA2121 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BA2121 } /* Literal.String.Single */
body .ss { color: #19177C } /* Literal.String.Symbol */
body .bp { color: #008000 } /* Name.Builtin.Pseudo */
body .fm { color: #0000FF } /* Name.Function.Magic */
body .vc { color: #19177C } /* Name.Variable.Class */
body .vg { color: #19177C } /* Name.Variable.Global */
body .vi { color: #19177C } /* Name.Variable.Instance */
body .vm { color: #19177C } /* Name.Variable.Magic */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
<body>
<h2></h2>

<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="c1"># using __slots__ for optimization</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;osmid&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">]</span>
    <span class="c1"># constructor for each node</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span><span class="n">graph</span> <span class="p">,</span> <span class="n">osmid</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># the dictionary of each node as in networkx graph --- still needed for internal usage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">osmid</span><span class="p">]</span>

        <span class="c1"># the distance from the parent node --- edge length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span>

        <span class="c1"># the parent node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>

        <span class="c1"># unique identifier for each node so we don&#39;t use the dictionary returned from osmnx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">osmid</span> <span class="o">=</span> <span class="n">osmid</span>

        <span class="c1"># the graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">graph</span>

    <span class="c1"># returning all the nodes adjacent to the node</span>
    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">Node</span><span class="p">(</span><span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">osmid</span> <span class="o">=</span> <span class="n">child</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">child</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;length&#39;</span><span class="p">],</span> <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="p">)</span> \
                        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">children</span>

    <span class="c1"># returns the path from that node to the origin as a list and the length of that path</span>
    <span class="k">def</span> <span class="nf">path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">return</span> <span class="n">path</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># the following two methods are for dictating how comparison works</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">osmid</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">osmid</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">osmid</span> <span class="o">==</span> <span class="n">other</span>


    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">osmid</span><span class="p">)</span>
</pre></div>
</body>
</html>
</div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># The Algorithm</span>
<span class="c1"># first define the origin/source nodes as Node</span>
<span class="n">origin</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">graph</span> <span class="o">=</span> <span class="n">G</span><span class="p">,</span> <span class="n">osmid</span> <span class="o">=</span> <span class="mi">55808290</span><span class="p">)</span>
<span class="n">destination</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">graph</span> <span class="o">=</span> <span class="n">G</span><span class="p">,</span> <span class="n">osmid</span> <span class="o">=</span> <span class="mi">389677909</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%time</span>
<span class="n">bar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>

<span class="c1"># this is where we would save our result at the end</span>
<span class="n">route</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># we will be using deque instead of normal python lists</span>
<span class="c1"># to have O(1) [pop/append]-ing instead of O(n) in lists</span>
<span class="c1"># because deques are implemented with linked-list and</span>
<span class="c1"># lists are implemented with arrays </span>

<span class="n">frontier</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">origin</span><span class="p">])</span>

<span class="c1"># this is a directed multigraph so we need to have memory</span>
<span class="c1"># so we don&#39;t get stuck in a loop</span>
<span class="n">explored</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">while</span> <span class="n">frontier</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
    <span class="n">bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span> <span class="c1"># for the progress bar -- ignore</span>

    <span class="n">node</span> <span class="o">=</span> <span class="n">frontier</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
    <span class="n">explored</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">expand</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span> <span class="ow">and</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">frontier</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span>
                <span class="n">route</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

<span class="n">bar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The route is </span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">route</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">its cost is</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> 59%|███████████████████████▍                | 227/387 [00:14&lt;00:10, 15.74it/s]
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The route is 

 [55808290, 304891685, 55808284, 1721866234, 389678268, 4953810915, 389678267, 24960090, 24960068, 1258698109, 389678145, 24960070, 24960073, 24960076, 24960080, 6028561924, 5098988924, 389678131, 2557539841, 389678133, 389677909] 

its cost is

 954.7269999999999
Wall time: 14.4 s
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">plot_graph_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph_search_algorithms_15_0.png" src="../../_images/graph_search_algorithms_15_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">draw_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id": "ccf79ee87ed9492a82fd45c70c094020", "version_major": 2, "version_minor": 0}
</script></div>
</div>
<p>We will be using uber’s <a class="reference external" href="https://kepler.gl/">kepler.gl</a> for one time in this notebook only to make you aware of it, but unfortunatley we won’t be using it because of its of its limited API.</p>
</div>
<div class="section" id="depth-first-search-dfs">
<h1>Depth-first Search (DFS)<a class="headerlink" href="#depth-first-search-dfs" title="Permalink to this headline">¶</a></h1>
<p>The DFS algorithm is a recursive algorithm that uses the idea of backtracking. It involves exhaustive searches of all the nodes by going ahead, if possible, else by backtracking.</p>
<p><strong>DEPTH-FIRST-SEARCH</strong> ( <em>source</em> , <em>destination</em> ) <strong>return</strong> a route<br />
 <em>frontier</em> ← a <strong>LIFO</strong> initialized with <em>source</em> node<br />
 <em>explored</em> ← <em>empty</em><br />
 <em>found</em> ← <em>False</em><br />
 <strong>while</strong>  <em>frontier</em> <strong>is not</strong> <em>empty</em> <strong>and</strong> <em>found</em> <strong>is</strong> <em>False</em> <strong>do</strong><br />
   <em>node</em> ← <em>frontier</em>.pop()<br />
   <strong>add</strong> <em>node</em> <strong>to</strong> <em>explored</em><br />
   <strong>for</strong> <em>child</em> <strong>in</strong> <em>node</em>.expand() <strong>do</strong><br />
     <strong>if</strong> <em>child</em> <strong>is not in</strong> <em>explored</em> <strong>and</strong> <em>child</em> <strong>is not in</strong> <em>frontier</em>   <strong>then</strong><br />
        <strong>if</strong> <em>child</em> <strong>is</strong> <em>destination</em> <strong>then</strong><br />
          <em>route</em> ← <em>child</em>.route()<br />
          <em>found</em> ← <em>True</em><br />
       <strong>add</strong> <em>child</em> <strong>to</strong> <em>frontier</em><br />
 <strong>return</strong>  <em>route</em></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># The Algorithm</span>
<span class="n">bar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>

<span class="n">route</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">frontier</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">origin</span><span class="p">])</span>
<span class="n">explored</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">while</span> <span class="n">frontier</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
    <span class="n">bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">frontier</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="n">explored</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">expand</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span> <span class="ow">and</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">frontier</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span>
                <span class="n">route</span>  <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">continue</span>
            <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

<span class="n">bar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The route is </span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">route</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">its cost is</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> 14%|█████▌                                   | 53/387 [00:03&lt;00:21, 15.78it/s]
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The route is 

 [55808290, 55808177, 55808169, 55808239, 389678268, 4953810915, 4953810914, 55808233, 299625330, 24959523, 50885177, 389677947, 1840221695, 1840221686, 1840221676, 783622470, 389678138, 3707407638, 6028561924, 6028561921, 389678124, 6028562355, 2557542523, 389677907, 389678038, 389678039, 389678040, 2143436381, 389678041, 389678184, 389678183, 389678216, 7311057931, 749951161, 242413453, 749952029, 389677909] 

its cost is

 1521.5479999999995
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">draw_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id": "4f40ba1c41c245a2849e360a9b89ad69", "version_major": 2, "version_minor": 0}
</script></div>
</div>
</div>
<div class="section" id="dijkstra-search">
<h1>Dijkstra Search<a class="headerlink" href="#dijkstra-search" title="Permalink to this headline">¶</a></h1>
<p>Dijkstra’s algorithm allows us to find the shortest path between any two vertices of a graph. The algorithm creates a tree of shortest paths from the starting vertex, the source, to all other points in the graph.  Dijkstra’s algorithm , published in 1959 and named after its creator Dutch computer scientist Edsger Dijkstra, is the base of several other graph search algorithms commonly used to solve routing problems in the navigation apps.</p>
<img src="images/Dijkstra.png" alt="Dijkstra Algorithms" style="float: left; margin-right: 10px;" />
<p>// this is modified version from the standard Dijkstra because<br />
// graphs from generated from maps have self-loops and parallel edges<br />
// which breaks dijkstra because self-loop edge could get choosen in the<br />
// priority queue step and mess the order of relaxation of the nodes
// this may not very obvious at first but trace the algorithm and you would<br />
// see what we meant</p>
<p>// when a node get removed from <em>unrelaxed_nodes</em> list, then this node value<br />
// in <em>shortest_dist</em> is the shortest path between the origin and that node – it became relaxed</p>
<p><strong>DIJKSTRA-SEARCH</strong>( <em>source</em> , <em>destination</em> ) <strong>returns</strong> a route<br />
 <em>shortest_dist</em> ← empty<br />
 <em>unrelaxed_nodes</em> ← empty<br />
 <em>seen</em> ← empty</p>
<p> //initializing the lists<br />
 <strong>for</strong> <em>node</em> <strong>in</strong> <em>graph</em><br />
   <em>shortest_dist</em> [ <em>node</em> ] = <em>Infinity</em><br />
   <strong>add</strong> <em>node</em> <strong>to</strong> <em>unrelaxed_nodes</em></p>
<p>  <em>shortest_dist</em> [ <em>source</em> ] ← 0<br />
  <em>found</em> ← <em>False</em></p>
<p>  <strong>while</strong> <em>unrelaxed_nodes</em> <strong>is not</strong> empty <strong>and</strong> <em>found</em> <strong>is</strong> <em>False</em> <strong>do</strong><br />
   <em>node</em> ← <em>unrelaxed_nodes</em>.pop()  // this will return the node with the smallest value in <em>shortest_dist</em> list<br />
   <strong>add</strong> <em>node</em> <strong>to</strong> <em>seen</em><br />
   <strong>if</strong> <em>node</em> <strong>is</strong> <em>destination</em> <strong>then</strong><br />
    <em>route</em> ← <em>node</em>.route()<br />
    <em>found</em> ← <em>True</em><br />
   <strong>for</strong> <em>child</em> <strong>in</strong> <em>node</em>.expand() <strong>do</strong><br />
    <strong>if</strong> <em>child</em> <strong>in</strong> <em>seen</em> : <strong>skip</strong><br />
    <em>distance</em> ← <em>shortest_dist</em> [ <em>node</em> ] + length of edge to <em>child</em><br />
    <strong>if</strong> <em>distance</em> &lt; <em>shortest_dist</em> [ <em>child</em> ] :   //relax this edge<br />
     <em>shortest_dist</em> [ <em>child</em> ] ← <em>distance</em><br />
     <em>child</em>.partent ← <em>node</em><br />
 <strong>return</strong>  <em>route</em></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%time</span>
<span class="n">bar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>

<span class="c1"># we will be dealing with the id of the nodes of the graph in our lists</span>
<span class="c1"># except for unrelaxed_node list where we need to have an actual `Node` object</span>
<span class="c1"># so we can invoke the path() function on it when we arrive at destination</span>

<span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>         <span class="c1"># for dealing with self loops</span>

<span class="n">shortest_dist</span> <span class="o">=</span> <span class="p">{</span><span class="n">osmid</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span> <span class="k">for</span> <span class="n">osmid</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>
<span class="n">unrelaxed_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Node</span><span class="p">(</span><span class="n">graph</span> <span class="o">=</span> <span class="n">G</span><span class="p">,</span> <span class="n">osmid</span> <span class="o">=</span> <span class="n">osmid</span><span class="p">)</span> <span class="k">for</span> <span class="n">osmid</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>

<span class="n">shortest_dist</span><span class="p">[</span><span class="n">origin</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">unrelaxed_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
    <span class="n">bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
    
    <span class="n">node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">unrelaxed_nodes</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">shortest_dist</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">])</span>
    
    <span class="c1"># relaxing the node, so this node&#39;s value in shortest_dist</span>
    <span class="c1"># is the shortest distance between the origin and destination</span>
    <span class="n">unrelaxed_nodes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">)</span>
        
    <span class="c1"># if the destination node has been relaxed</span>
    <span class="c1"># then that is the route we want</span>
    <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span>
        <span class="n">route</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">path</span><span class="p">()</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">shortest_dist</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">continue</span>
    
    <span class="c1"># otherwise, let&#39;s relax edges of its neighbours</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">expand</span><span class="p">():</span>
        <span class="c1"># skip self-loops</span>
        <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">osmid</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span> <span class="k">continue</span>
        
        <span class="c1"># this doesn&#39;t look pretty because Node is just an object</span>
        <span class="c1"># so retrieving it is a bit verbose -- if you have nicer </span>
        <span class="c1"># way to do that, please open an issue</span>
        <span class="n">child_obj</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">unrelaxed_nodes</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">osmid</span> <span class="o">==</span> <span class="n">child</span><span class="o">.</span><span class="n">osmid</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">child_obj</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">distance</span>
        
        <span class="n">distance</span> <span class="o">=</span> <span class="n">shortest_dist</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span> <span class="o">+</span> <span class="n">child</span><span class="o">.</span><span class="n">distance</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">shortest_dist</span><span class="p">[</span><span class="n">child_obj</span><span class="o">.</span><span class="n">osmid</span><span class="p">]:</span>
            <span class="n">shortest_dist</span><span class="p">[</span><span class="n">child_obj</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
            <span class="n">child_obj</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">node</span>
            
<span class="n">bar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The route is </span><span class="se">\n\n</span><span class="si">{</span><span class="n">route</span><span class="si">}</span><span class="s2"> </span><span class="se">\n\n</span><span class="s2">its cost is</span><span class="se">\n\n</span><span class="si">{</span><span class="n">cost</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> 96%|██████████████████████████████████████▍ | 372/387 [00:23&lt;00:00, 15.72it/s]
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The route is 

[55808290, 304891685, 55808284, 1252869817, 55808239, 389678268, 4953810915, 389678267, 24960090, 389678273, 24959523, 50885177, 389677947, 2143489692, 2480712846, 389678140, 389678139, 389678138, 3707407638, 6028561924, 5098988924, 389678131, 6028562356, 854322047, 389677908, 749952029, 389677909] 

its cost is

801.4639999999998
Wall time: 23.7 s
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">draw_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id": "4717051fb0d240ec87ab2642e6673305", "version_major": 2, "version_minor": 0}
</script></div>
</div>
</div>
<div class="section" id="hill-climbing">
<h1>Hill Climbing<a class="headerlink" href="#hill-climbing" title="Permalink to this headline">¶</a></h1>
<p>The idea of the algorithm is simple; if you have a value of objective function that you want to optimize, you check the neighbours of that value and choose the neighbour that has more optimal value. If there is not such neighbour, terminate the search and return the current value.</p>
<p>With that, you can get easily stuck at local optimal points, and flat areas in the objective function where there is no progress.</p>
<p><strong>HILL-CLIMBING</strong>( <em>source</em> , <em>destination</em> ) <strong>returns</strong> a route<br />
  <em>current</em> ← random route from <em>source</em> , <em>destination</em><br />
  <em>neighbours</em> ← children of <em>current</em><br />
  <strong>while</strong> min <em>neighbours</em> &lt; <em>current</em> <strong>do</strong><br />
   <em>current</em> ← min <em>neighbours</em><br />
   <em>neighbours</em> ← children of <em>current</em><br />
  <strong>return</strong> <em>current</em></p>
<hr class="docutils" />
<p>This is the first time to use the idea of generating children of a route and treating the route between two specific nodes as a function with a value which is the distance between these two nodes.</p>
<p>Let’s talk about that again (the first time is <a class="reference external" href="https://github.com/SmartMobilityAlgorithms/GettingStarted/blob/master/utils.ipynb">here</a>), we needed a function defined to be optimized in the first place; a function over all the possible routes between two specific nodes that we are trying to find the shortest path between them. We could have generated random permutations between these two nodes and took the permutations that are actual and feasible routes between them and optimize our “function” over these random, sparse permutations. But with that we can’t say we are stuck at local optimum value or that we reproduce the same output every run because these are just random permutations.</p>
<p>What we did is that we have made a determinstic policy that generates number of routes between two nodes by successively failing nodes between source and destination and have a gap in the route which will be stitched with the shortest path between the node before the failure and the node after the failure.</p>
<p>By failing the nodes in a determinstic fashion, we can say that we have a function and neighbourhood with defined size for a certain value so we can “rigorously” talk about local search.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%time</span>
<span class="c1"># we will only take 20 child to make the algorithm running lightweight</span>

<span class="n">current</span> <span class="o">=</span> <span class="n">randomized_search</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">origin</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span> <span class="n">destination</span><span class="o">.</span><span class="n">osmid</span><span class="p">)</span>
<span class="n">neighbours</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">islice</span><span class="p">(</span><span class="n">children_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">current</span><span class="p">),</span> <span class="mi">25</span><span class="p">)]</span> 
<span class="n">shortest</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">neighbours</span> <span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">route</span> <span class="p">:</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">))</span>

<span class="c1"># sometimes the random generated route is what you got</span>
<span class="c1"># and no iterations happen at all</span>

<span class="k">while</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">shortest</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">current</span><span class="p">):</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">shortest</span>
    <span class="n">neighbours</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">islice</span><span class="p">(</span><span class="n">children_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">current</span><span class="p">),</span> <span class="mi">25</span><span class="p">)]</span>
    <span class="n">shortest</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">neighbours</span> <span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">route</span> <span class="p">:</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">))</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The cost of the path now is </span><span class="se">\n\n</span><span class="si">{</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span><span class="si">}</span><span class="s2"> and the best child is </span><span class="se">\n\n</span><span class="si">{</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">shortest</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">TypeError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">timed</span> <span class="n">exec</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>

<span class="nn">&lt;timed exec&gt;</span> in <span class="ni">&lt;lambda&gt;</span><span class="nt">(route)</span>

<span class="ne">TypeError</span>: &#39;float&#39; object is not callable
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">draw_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id": "b829998abcc44070b7c83bb105aca63c", "version_major": 2, "version_minor": 0}
</script></div>
</div>
<p>You probably are going to get a good results because there is not many local optimal points in the route function, but imagine having much bigger search space with a lot of valley and hills, you will get stuck very fast.</p>
<p>It is like climbing a mountain and you only can see 1 meter around you, so if you stand on a rock at the bottom of the moutain, it is the top of “your” mounatin.</p>
</div>
<div class="section" id="beam-search">
<h1>Beam Search<a class="headerlink" href="#beam-search" title="Permalink to this headline">¶</a></h1>
<p>Instead of keeping one state/route in the memory that persists through all the iterations like in hill climbing, we will keep <span class="math notranslate nohighlight">\(k\)</span> states in our memory/beam and at each iteration we generate the neighbours of each of the <span class="math notranslate nohighlight">\(k\)</span> state/route and put them in a pool with also the <span class="math notranslate nohighlight">\(k\)</span> routes in the original beam and then select the best <span class="math notranslate nohighlight">\(k\)</span> routes from the pool to be our next <em>beam</em> that would go into the next iteration of generation and selection. We terminate the algorithm when the beam of the current iteration is the same as the beam from the last iteration, this is a local search after all and we can get stuck at local minima.</p>
<p><strong>BEAM-SEARCH</strong>( <em>source</em> , <em>destination</em> , <em>k</em> ) <strong>returns</strong> a route<br />
  <em>seen</em> ← nil   // so we don’t have one sinlge short route generated from multiple parent dominates <em>beam</em><br />
  <em>beam</em> ← random <span class="math notranslate nohighlight">\(k\)</span> routes from <em>source</em> , <em>destination</em><br />
  add <em>beam</em> to <em>seen</em><br />
  <em>pool</em> ← children of routes in the <em>beam</em> with consideration of <em>seen</em> + <em>beam</em><br />
  <em>last_beam</em> ← nil<br />
  <strong>while</strong> <em>beam</em> <strong>is not</strong> <em>last_beam</em> <strong>do</strong><br />
   <em>last_beam</em> ← <em>beam</em><br />
   <em>beam</em> ← the best <span class="math notranslate nohighlight">\(k\)</span> routes from <em>pool</em><br />
   add <em>beam</em> to <em>seen</em><br />
   <em>pool</em> ← children of routes in the <em>beam</em> with consideration of <em>seen</em> + <em>beam</em><br />
  <strong>return</strong> optimal route in <em>beam</em></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">num_neighbours</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">10</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%time</span>
<span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">beam</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomized_search</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">origin</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span> <span class="n">destination</span><span class="o">.</span><span class="n">osmid</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>

<span class="c1"># we needed to &quot;tuple&quot; route as a list to make it hashable </span>
<span class="c1"># so we can add it inside a python set data structure</span>
<span class="k">for</span> <span class="n">route</span> <span class="ow">in</span> <span class="n">beam</span><span class="p">:</span> <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">route</span><span class="p">))</span>

<span class="n">pool</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">route</span> <span class="ow">in</span> <span class="n">beam</span><span class="p">:</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">islice</span><span class="p">(</span><span class="n">children_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">),</span> <span class="n">num_neighbours</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">pool</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">);</span> <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
<span class="n">pool</span> <span class="o">+=</span> <span class="n">beam</span>

<span class="n">last_beam</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">while</span> <span class="n">beam</span> <span class="o">!=</span> <span class="n">last_beam</span><span class="p">:</span>
    <span class="n">last_beam</span> <span class="o">=</span> <span class="n">beam</span>
    <span class="n">beam</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">route</span><span class="p">:</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">route</span> <span class="ow">in</span> <span class="n">beam</span><span class="p">:</span> <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">route</span><span class="p">))</span> 
    
    <span class="n">pool</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">route</span> <span class="ow">in</span> <span class="n">beam</span><span class="p">:</span>
        <span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">islice</span><span class="p">(</span><span class="n">children_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">),</span> <span class="n">num_neighbours</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">pool</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">);</span> <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
    <span class="n">pool</span> <span class="o">+=</span> <span class="n">beam</span>
            
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The cost of the routes in the beam are </span><span class="si">{</span><span class="p">[</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span> <span class="k">for</span> <span class="n">route</span> <span class="ow">in</span> <span class="n">beam</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">route</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">route</span> <span class="p">:</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">))</span> 
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The route is </span><span class="se">\n\n</span><span class="si">{</span><span class="n">route</span><span class="si">}</span><span class="s2"> </span><span class="se">\n\n</span><span class="s2">its cost is</span><span class="se">\n\n</span><span class="si">{</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">TypeError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">timed</span> <span class="n">exec</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>

<span class="nn">C:\Anaconda3\envs\uoft\lib\heapq.py</span> in <span class="ni">nsmallest</span><span class="nt">(n, iterable, key)</span>
<span class="g g-Whitespace">    </span><span class="mi">506</span>     <span class="c1"># General case, slowest method</span>
<span class="g g-Whitespace">    </span><span class="mi">507</span>     <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
<span class="ne">--&gt; </span><span class="mi">508</span>     <span class="n">result</span> <span class="o">=</span> <span class="p">[(</span><span class="n">key</span><span class="p">(</span><span class="n">elem</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">it</span><span class="p">)]</span>
<span class="g g-Whitespace">    </span><span class="mi">509</span>     <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="g g-Whitespace">    </span><span class="mi">510</span>         <span class="k">return</span> <span class="n">result</span>

<span class="nn">C:\Anaconda3\envs\uoft\lib\heapq.py</span> in <span class="ni">&lt;listcomp&gt;</span><span class="nt">(.0)</span>
<span class="g g-Whitespace">    </span><span class="mi">506</span>     <span class="c1"># General case, slowest method</span>
<span class="g g-Whitespace">    </span><span class="mi">507</span>     <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
<span class="ne">--&gt; </span><span class="mi">508</span>     <span class="n">result</span> <span class="o">=</span> <span class="p">[(</span><span class="n">key</span><span class="p">(</span><span class="n">elem</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">it</span><span class="p">)]</span>
<span class="g g-Whitespace">    </span><span class="mi">509</span>     <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="g g-Whitespace">    </span><span class="mi">510</span>         <span class="k">return</span> <span class="n">result</span>

<span class="nn">&lt;timed exec&gt;</span> in <span class="ni">&lt;lambda&gt;</span><span class="nt">(route)</span>

<span class="ne">TypeError</span>: &#39;float&#39; object is not callable
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">draw_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id": "f0b3a4b1202a4b9187e4508ce4aebb0f", "version_major": 2, "version_minor": 0}
</script></div>
</div>
</div>
<div class="section" id="a-search">
<h1>A* Search<a class="headerlink" href="#a-search" title="Permalink to this headline">¶</a></h1>
<p>A* is an informed search algorithm widely used in pathfinding and graph traversal.</p>
<p><strong>PQ</strong> ← min heap according to <strong>A-star heuristic</strong><br />
<strong>A-star heuristic</strong> ← sum of straight-line distance between the node to <em>goal</em> and the node to <em>destination</em></p>
<p><strong>A*-SEARCH</strong> ( <em>source</em> , <em>destination</em> ) <strong>return</strong> a route<br />
 <em>frontier</em> ← a <strong>PQ</strong> initialized with <em>source</em> node<br />
 <em>explored</em> ← empty<br />
 <em>found</em> ← False<br />
 <strong>while</strong>  <em>frontier</em> <strong>is not</strong> empty <strong>and</strong> <em>found</em> <strong>is</strong> <em>False</em>  <strong>do</strong><br />
   <em>node</em> ← <em>frontier</em>.pop()<br />
   <strong>add</strong> <em>node</em> <strong>to</strong> <em>explored</em><br />
   <strong>for</strong> <em>child</em> <strong>in</strong> <em>node</em>.expand() <strong>do</strong><br />
     <strong>if</strong> <em>child</em> <strong>is not in</strong> <em>explored</em> <strong>and</strong> <em>child</em> <strong>is not in</strong> <em>frontier</em>   <strong>then</strong><br />
        <strong>if</strong> <em>child</em> <strong>is</strong> <em>destination</em> <strong>then</strong><br />
          <em>route</em> ← <em>child</em>.route()<br />
          <em>found</em> ← <em>True</em><br />
       <strong>add</strong> <em>child</em> <strong>to</strong> <em>frontier</em><br />
 <strong>return</strong>  <em>route</em></p>
<div class="section" id="the-heuristic">
<h2>The Heuristic<a class="headerlink" href="#the-heuristic" title="Permalink to this headline">¶</a></h2>
<p>What drives node expansion in A* algorithm is determining is choosing a node with the lowest heuristic value which is computer by summing the straight line distance between the node and the origin and the straight line distance between the node and the source so what we need here is a function that returns a data structure that pre-computes this value for each node.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">source</span><span class="p">(</span><span class="n">astar_heuristic</span><span class="p">)</span>
<span class="c1"># x, y are longitude and latitude</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<!--
generated by Pygments <https://pygments.org/>
Copyright 2006-2019 by the Pygments team.
Licensed under the BSD license, see LICENSE for details.
-->
<html>
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=None">
  <style type="text/css">
/*
generated by Pygments <https://pygments.org/>
Copyright 2006-2019 by the Pygments team.
Licensed under the BSD license, see LICENSE for details.
*/
td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }
body .hll { background-color: #ffffcc }
body  { background: #f8f8f8; }
body .c { color: #408080; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #008000; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
body .cm { color: #408080; font-style: italic } /* Comment.Multiline */
body .cp { color: #BC7A00 } /* Comment.Preproc */
body .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
body .c1 { color: #408080; font-style: italic } /* Comment.Single */
body .cs { color: #408080; font-style: italic } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
body .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #008000 } /* Keyword.Pseudo */
body .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #B00040 } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BA2121 } /* Literal.String */
body .na { color: #7D9029 } /* Name.Attribute */
body .nb { color: #008000 } /* Name.Builtin */
body .nc { color: #0000FF; font-weight: bold } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #0000FF } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #19177C } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mb { color: #666666 } /* Literal.Number.Bin */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sa { color: #BA2121 } /* Literal.String.Affix */
body .sb { color: #BA2121 } /* Literal.String.Backtick */
body .sc { color: #BA2121 } /* Literal.String.Char */
body .dl { color: #BA2121 } /* Literal.String.Delimiter */
body .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BA2121 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BA2121 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BA2121 } /* Literal.String.Single */
body .ss { color: #19177C } /* Literal.String.Symbol */
body .bp { color: #008000 } /* Name.Builtin.Pseudo */
body .fm { color: #0000FF } /* Name.Function.Magic */
body .vc { color: #19177C } /* Name.Variable.Class */
body .vg { color: #19177C } /* Name.Variable.Global */
body .vi { color: #19177C } /* Name.Variable.Instance */
body .vm { color: #19177C } /* Name.Variable.Magic */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
<body>
<h2></h2>

<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">astar_heuristic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">measuring_dist</span> <span class="o">=</span> <span class="n">straight_line</span><span class="p">):</span>
    <span class="n">distanceGoal</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">distanceOrigin</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="n">originX</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">origin</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
    <span class="n">originY</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">origin</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>

    <span class="n">destX</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">destination</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
    <span class="n">destY</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">destination</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="n">pointX</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
        <span class="n">pointY</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>

        <span class="n">originDist</span> <span class="o">=</span> <span class="n">measuring_dist</span><span class="p">(</span><span class="n">originX</span><span class="p">,</span> <span class="n">originY</span><span class="p">,</span> <span class="n">pointX</span><span class="p">,</span> <span class="n">pointY</span><span class="p">)</span>
        <span class="n">destDist</span> <span class="o">=</span> <span class="n">measuring_dist</span><span class="p">(</span><span class="n">pointX</span><span class="p">,</span> <span class="n">pointY</span><span class="p">,</span> <span class="n">destX</span><span class="p">,</span> <span class="n">destY</span><span class="p">)</span>

        <span class="n">distanceGoal</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">originDist</span>
        <span class="n">distanceOrigin</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">destDist</span>

    <span class="k">return</span> <span class="n">distanceGoal</span><span class="p">,</span> <span class="n">distanceOrigin</span>
</pre></div>
</body>
</html>
</div></div>
</div>
<p>In this implementation we assume that earth is flat which is acceptable approximation if our map is small but if we want to get it exactly right, we will need to compute <a class="reference external" href="https://en.wikipedia.org/wiki/Haversine_formula">haversine formula</a>.</p>
<p>You can do so by changing the measuring dist to <code class="docutils literal notranslate"><span class="pre">haversine_distance</span></code> instead the default <code class="docutils literal notranslate"><span class="pre">straight_distance</span></code>. If the area you query is relatively small, straight distance would give better results.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">toGoal</span><span class="p">,</span> <span class="n">toDestination</span> <span class="o">=</span> <span class="n">astar_heuristic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">origin</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span> <span class="n">destination</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span> <span class="n">measuring_dist</span> <span class="o">=</span> <span class="n">haversine_distance</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%time</span>
<span class="n">route</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">frontier</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">))</span> <span class="c1"># for the progress bar</span>

<span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
<span class="n">explored</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">while</span> <span class="n">frontier</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
    <span class="n">bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
    
    <span class="c1"># choose a node based on its heuristic value</span>
    <span class="n">node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">frontier</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">toGoal</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span> <span class="o">+</span> <span class="n">toDestination</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">])</span>
    <span class="n">frontier</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="n">explored</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    
    <span class="c1"># expand its children</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">expand</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span> <span class="ow">and</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">frontier</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span>
                <span class="n">route</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">continue</span>
            <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

<span class="n">bar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The route is </span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">route</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">its cost is</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> 19%|███████▋                                 | 73/387 [00:04&lt;00:19, 15.77it/s]
</pre></div>
</div>
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">TypeError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">timed</span> <span class="n">exec</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>

<span class="ne">TypeError</span>: &#39;float&#39; object is not callable
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">draw_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id": "c4a29b99e38d422e98c5d21a24cf2a37", "version_major": 2, "version_minor": 0}
</script></div>
</div>
</div>
</div>
<div class="section" id="bi-directional-search">
<h1>Bi-directional Search<a class="headerlink" href="#bi-directional-search" title="Permalink to this headline">¶</a></h1>
<p>The point of bidirectional search is to run two simultaneous, not parallel, search from the origin and destination node hoping that they would meet in the middle.  Imagine that you are doing BFS in a graph with a constant branching factor <span class="math notranslate nohighlight">\(b\)</span> and depth <span class="math notranslate nohighlight">\(d\)</span> so the complexity would be <span class="math notranslate nohighlight">\(O({d}^b)\)</span> but what if we split that depth <span class="math notranslate nohighlight">\(d\)</span> in half (that usually doesn’t happen) so the total complexity would be <span class="math notranslate nohighlight">\(O({(d/2)}^b) + O({(d/2)}^b)\)</span> which is in total much lower than <span class="math notranslate nohighlight">\(O({d}^b)\)</span>.</p>
<p><strong>Bi_DIRECTIONAL_SEARCH</strong> ( <em>source</em> , <em>destination</em> ) <strong>returns</strong> a route</p>
<p>  // f stands for source/front expansion and b stands for destination/back expansion</p>
<p>  <em>frontier_f</em> ← initialized with <em>source</em><br />
  <em>frontier_b</em> ← initialized with <em>destination</em><br />
  <em>explored_f</em> ← empty<br />
  <em>explored_b</em> ← empty<br />
  <em>collide</em> ← <em>False</em>    // if front expansion overlapped with back expansion<br />
  <em>found</em> ← <em>False</em>    // if we found the destination from a single expansion which if you think about it, will never happen<br />
  <em>altr_expand</em> ← <em>False</em>    // To alternate between expansion from front and back</p>
<p>  <strong>while</strong> <em>frontier_f</em> <strong>is not</strong> empty <strong>and</strong> <em>frontier_b</em> <strong>is not</strong> empty <strong>and</strong> <strong>not</strong> <em>collide</em> <strong>and</strong> <strong>not</strong> <em>found</em> <strong>do</strong><br />
   <strong>if</strong> <em>altr_expand</em> <strong>then</strong><br />
    <em>node</em> ← <em>frontier_f</em>.pop()<br />
    <strong>add</strong> <em>node</em> <strong>to</strong> <em>explored_f</em><br />
    <strong>for</strong> <em>child</em> <strong>in</strong> <em>node</em>.expand() <strong>do</strong><br />
     <strong>if</strong> <em>child</em> <strong>in</strong> <em>explored_f</em> <strong>then</strong> continue<br />
     <strong>if</strong> <em>child</em> <strong>is</strong> <em>destination</em> <strong>then</strong><br />
      <em>route</em> ← <em>child</em>.route()<br />
      <em>found</em> ← <em>True</em><br />
     <strong>if</strong> <em>child</em> <strong>is in</strong> <em>explored_b</em> <strong>then</strong>  //overlapping – met in the middle<br />
      <em>route</em> ← <em>child</em>.route() + reverse( <em>overlapped</em>.route() )<br />
      <em>collid</em> ← <em>True</em><br />
     <strong>add</strong> <em>child</em> <strong>to</strong> <em>frontier_f</em><br />
   <strong>else</strong><br />
    <em>node</em> ←  <em>frontier_b</em>.pop()<br />
    <strong>add</strong> <em>node</em> <strong>to</strong> <em>explored_b</em><br />
    <strong>for</strong> <em>child</em> <strong>in</strong> <em>node</em>.expand() <strong>do</strong><br />
     <strong>if</strong> <em>child</em> <strong>in</strong> <em>explored_b</em> <strong>then</strong> continue<br />
     <strong>if</strong> <em>child</em> <strong>is</strong> <em>destination</em> <strong>then</strong><br />
      <em>route</em> ← <em>child</em>.route()<br />
      <em>found</em> ← <em>True</em><br />
     <strong>if</strong> <em>child</em> <strong>is in</strong> <em>explored_f</em> <strong>then</strong>  //overlapping – met in the middle<br />
      <em>route</em> ← reverse( <em>child</em>.route() ) + <em>overlapped</em>.route()<br />
      <em>collid</em> ← <em>True</em><br />
     <strong>add</strong> <em>child</em> <strong>to</strong> <em>frontier_b</em><br />
  <strong>return</strong> <em>route</em></p>
<p>Le’s implement A* based bi-directional search algorithm, so our criteria of expansion, either from source frontier or destination destination frontier is the A* heuristic.</p>
<p>Please note the following:</p>
<ol class="simple">
<li><p>the origin and destination for the expansion from destionation node are reversed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> stands for frontier (source expansion), <code class="docutils literal notranslate"><span class="pre">b</span></code> stands for back (destination expansion)</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># first define the origin/source nodes as Node</span>
<span class="n">origin</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">graph</span> <span class="o">=</span> <span class="n">G</span><span class="p">,</span> <span class="n">osmid</span> <span class="o">=</span> <span class="mi">55808290</span><span class="p">)</span>
<span class="n">destination</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">graph</span> <span class="o">=</span> <span class="n">G</span><span class="p">,</span> <span class="n">osmid</span> <span class="o">=</span> <span class="mi">389677909</span><span class="p">)</span>
<span class="n">destination_b</span> <span class="o">=</span> <span class="n">origin</span>
<span class="n">origin_b</span> <span class="o">=</span> <span class="n">destination</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">toGoal_f</span><span class="p">,</span> <span class="n">toDestination_f</span> <span class="o">=</span> <span class="n">astar_heuristic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">origin</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span> <span class="n">destination</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span> <span class="n">measuring_dist</span> <span class="o">=</span> <span class="n">haversine_distance</span><span class="p">)</span>
<span class="n">toGoal_b</span><span class="p">,</span> <span class="n">toDestination_b</span> <span class="o">=</span> <span class="n">astar_heuristic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">origin_b</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span> <span class="n">destination_b</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span> <span class="n">measuring_dist</span> <span class="o">=</span> <span class="n">haversine_distance</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%time</span>
<span class="n">route</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># uncomment the following line to see the progress bar</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>

<span class="n">f_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">toGoal_f</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span> <span class="o">+</span> <span class="n">toDestination_f</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span>
<span class="n">b_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">toGoal_b</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span> <span class="o">+</span> <span class="n">toDestination_b</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span>

<span class="n">frontier_f</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">frontier_b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

<span class="n">frontier_f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
<span class="n">frontier_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">origin_b</span><span class="p">)</span>

<span class="n">explored_f</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">explored_b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

<span class="n">collide</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">altr_exapnd</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># to alternate between front and back</span>

<span class="k">while</span> <span class="n">frontier_f</span> <span class="ow">and</span> <span class="n">frontier_b</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">collide</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
    <span class="n">bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">altr_exapnd</span><span class="p">:</span>
        <span class="c1"># remove node_f from frontier_f to expand it</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">frontier_f</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">f_value</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        <span class="n">frontier_f</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">explored_f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">expand</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">explored_f</span><span class="p">:</span> <span class="k">continue</span>
            
            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span>
                <span class="n">route</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="c1"># checking for collusion with the target expansion</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">explored_b</span><span class="p">:</span>
                <span class="n">overlapped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">explored_b</span> <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">child</span><span class="p">))</span>
                <span class="c1"># we don&#39;t take the overlapped node twice</span>
                <span class="n">route</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">overlapped</span><span class="o">.</span><span class="n">path</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">collide</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="n">frontier_f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">altr_exapnd</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># remove node_b from frontier_b to expand it</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">frontier_b</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">b_value</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        <span class="n">frontier_b</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">explored_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">expand</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">explored_b</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">destination_b</span><span class="p">:</span>
                <span class="n">route</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># we reverse the list because we expand from the back</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">explored_f</span><span class="p">:</span>
                <span class="n">overlapped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">explored_f</span> <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">child</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">route</span> <span class="o">=</span> <span class="n">overlapped</span><span class="o">.</span><span class="n">path</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">collide</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="n">frontier_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">altr_exapnd</span> <span class="o">=</span> <span class="kc">True</span>


<span class="n">bar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The route is </span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> 14%|█████▋                                   | 54/387 [00:03&lt;00:21, 15.76it/s]
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The route is 

 [55808290, 304891685, 55808284, 1252869817, 55808239, 389678268, 4953810915, 389678267, 24960090, 389678273, 1258698113, 389678151, 389678142, 2143489694, 389678141, 2143488528, 389678140, 249991437, 3707407641, 24960080, 6028561924, 6028561921, 389678131, 6028562356, 854322047, 389677908, 749952029, 389677909]
Wall time: 3.43 s
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">draw_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id": "d73e3d9a8d7249eb89872acf70574e37", "version_major": 2, "version_minor": 0}
</script></div>
</div>
</div>
<div class="section" id="hierarchical-approaches">
<h1>Hierarchical Approaches<a class="headerlink" href="#hierarchical-approaches" title="Permalink to this headline">¶</a></h1>
<p>When we face problems with high complexity like doing routing over a graph of continent with millions of nodes, surely we won’t do Dijkstra or Depth First Search. We resort to do pruning of the search space and some precomputations that we can have stored on our servers, so when the user’s query arrives we are ready for it.</p>
<p>Hierarchical search algorithms prune the search space by generating admissible heuristic that abstracts the search space and thus pruning it. Read more about the general approach of hierarchical methods at <a class="reference external" href="https://www.aaai.org/ocs/index.php/SOCS/SOCS11/paper/viewFile/4035/4363">Faster Optimal and Suboptimal Hierarchical Search</a>.</p>
<p>We will now talk about two hierarchical approaches that solves the shortest path problem and how their heuristics are computed and after that we will be implementing contraction hierarchies algorithm.</p>
<div class="section" id="highway-hierarchies">
<h2>Highway Hierarchies<a class="headerlink" href="#highway-hierarchies" title="Permalink to this headline">¶</a></h2>
<p>It was described at <a class="reference external" href="https://link.springer.com/chapter/10.1007/11561071_51">Highway Hierarchies Hasten Exact Shortest Path Queries - ESA 2005</a>.</p>
<p>We compute hierarchy level for each <strong>arc</strong>/road in the graph to distinguish residential roads and national roads and highways and with some data about the arcs like the max speed and # of turns in the road would affect this distinction. After computing the heuristic function we run bi-directional Dijkstra/(or any type of search method) and as we run the algorithm we consider the level/heuristic value of the arcs when we expand a certain node like if we are very far away from our destination we only consider highways and if we are closer we look at national roads and if we are really close we traverse residential roads.</p>
<p>That is the pruning we talked about at the beginning, and the algorithm makes sense because if you are living at the side of the highway and want to go some place close to your place on the same side of where your at, you won’t take the highway and would prefer going through resdential roads, despite the fact that the highway is <em>faster</em>.</p>
</div>
<hr class="docutils" />
<div class="section" id="contraction-hierarchies">
<h2>Contraction Hierarchies<a class="headerlink" href="#contraction-hierarchies" title="Permalink to this headline">¶</a></h2>
<p>As you saw that the highway hierarchies algorithm gives us back 3 level/hierarchies (residential roads/ national roads/ highways) and that is how it prunes the search space and abstracts it into 3 choices. Contraction hierarchies introduced at <a class="reference external" href="https://link.springer.com/chapter/10.1007/978-3-540-68552-4_24">Contraction Hierarchies: Faster and Simpler Hierarchical Routing in Road Networks</a> gives us more levels of hierarchies (depends on the size of the graph) for each node based on when the node was <em>contracted</em>. The level of the node is its order of contraction relative to other nodes in the graph, and all the nodes in the graph are to be contracted eventually. Accordingly, the number of levels/hierarchies that the heuristic generates is equal to the number of nodes in the graph which is a good thing because the more hierarchies we have, the more we are pruning the search space.</p>
<p>We won’t get into the correctness proof of the algorithm, for that check the paper. If you are familiar with correctness proof of graph search algorithms, you will find it super straightforward.</p>
<div class="section" id="contraction">
<h3>Contraction<a class="headerlink" href="#contraction" title="Permalink to this headline">¶</a></h3>
<p>Take a node out from the graph and its adjacent edges and add new edges to the graph to keep the shortest path between all pairs of the rest of the nodes in the graph the same as if the node was still in the graph, that will produce another graph without the deleted node and its adjacent edges but with possible new added edges so you take another node out and its adjacent edges and add the necessary arcs. You keep going untill you contracted/deleted all nodes of the graph.</p>
<p>The new graph that would be used in the algorithm is the original graph with all the arcs that were added to keep the shortest path invariant through the process of contraction of all the nodes.</p>
<p>We compute the level of a node as its order of contraction, so the available levels are equal to the number of nodes in the graph; from 1 to n.</p>
<div class="section" id="what-order-of-contraction-to-the-nodes-should-i-follow">
<h4>What order of contraction to the nodes should I follow?<a class="headerlink" href="#what-order-of-contraction-to-the-nodes-should-i-follow" title="Permalink to this headline">¶</a></h4>
<p>Any order will make the algorithm runs successfuly, but some orders will shorten the time of contraction and minimizes the number of arcs addes to the graph.</p>
<p>We will see one in the implementation below.</p>
</div>
</div>
<div class="section" id="dijkstra">
<h3>Dijkstra<a class="headerlink" href="#dijkstra" title="Permalink to this headline">¶</a></h3>
<p>So after contraction we have a graph with nodes labeled with some level. We do dijkstra from the source and dijkstra from the destination.</p>
<p>The point of these two dijkstra is not about finding the destination, but to find the shortest path between the source and all the other nodes in the graph, but here is the catch:</p>
<p>We have a restriction over the dijkstra from the source and the dijkstra from the destionation.</p>
<ul class="simple">
<li><p>The dijkstra from the source only considers arcs <em>u</em>, <em>v</em> where level(<em>u</em>) &gt; level(<em>v</em>) so you only want to relax node with a higher level than the node you have relaxed at that iteration. This is called the <strong>upward graph</strong>.</p></li>
<li><p>The dijkstra from the destination only considers arcs <em>u</em>, <em>v</em> where level(<em>u</em>) &lt; level(<em>v</em>) so you only want to relax node with a lower level than the node you have relaxed at that iteration. This is called the <strong>downward graph</strong></p></li>
</ul>
<p>That is the pruning we talked about.</p>
<p>At the end you see the common nodes that have been relaxed from both (downward/upward) graphs and connect them and which would probably result into multiple paths between source and destination, so you choose the shortest path of these possible paths and return it.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">math</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>When you do contraction to compute the levels of the node, you need to produce new graph every time to do the next contraction. But that would be a lot of memory so you would just have a flag on every node that eliminates that node and its adjacent edges from the graph when contracted.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">contracted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">contracted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">contracted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">contracted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">contracted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="n">contracted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="n">contracted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="n">contracted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="n">contracted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">contracted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="n">contracted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="n">contracted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span><span class="n">contracted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="n">contracted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">7</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">6</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">13</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">1</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">13</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([</span><span class="o">*</span><span class="n">edges</span><span class="p">])</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph_search_algorithms_51_0.png" src="../../_images/graph_search_algorithms_51_0.png" />
</div>
</div>
<p>This is the normal dijkstra search to compute the shortest path between node <code class="docutils literal notranslate"><span class="pre">source</span></code> and <code class="docutils literal notranslate"><span class="pre">destination</span></code> if <code class="docutils literal notranslate"><span class="pre">contracted</span></code> flag is turned off.</p>
<p>If not, we give the <code class="docutils literal notranslate"><span class="pre">contracted</span></code> variable the number of the node that we want to contract and the algorithm computes the shortest path between the nodes accordingly.</p>
<p>Please note that we need to turn off the flag at the end of the function because the graph variable is passed by reference.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dijkstra_with_contraction</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">contracted</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">contracted</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span> <span class="s1">&#39;contracted&#39;</span><span class="p">)</span>
        
    <span class="n">shortest_path</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">heap</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;contracted&#39;</span><span class="p">)[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">shortest_path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">heap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">shortest_path</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        
        <span class="n">q</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">q</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">contracted</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span> <span class="s1">&#39;contracted&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">q</span><span class="p">]</span>
        <span class="n">heap</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">q</span><span class="p">]:</span>
            <span class="c1"># if the node is contracted we skip it</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;contracted&#39;</span><span class="p">)[</span><span class="n">v</span><span class="p">]:</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="n">shortest_path</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
                    
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">contracted</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span> <span class="s1">&#39;contracted&#39;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># if we can&#39;t reach the destination</span>
</pre></div>
</div>
</div>
</div>
<p>Computing the shortest path between every pair of nodes in the graph without any contraction. These values should be preserved through the contraction procedures.</p>
<p>Of course we can use networkx here instead like <a class="reference external" href="https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.shortest_paths.unweighted.all_pairs_shortest_path.html#networkx.algorithms.shortest_paths.unweighted.all_pairs_shortest_path"><code class="docutils literal notranslate"><span class="pre">nx.all_pairs_shortest_path</span></code></a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">shortest_paths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
    <span class="c1"># dictionary for every node</span>
    <span class="n">shortest_paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="c1"># that will be filled with the shortest path</span>
        <span class="c1"># between it and other nodes</span>
        <span class="n">shortest_paths</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dijkstra_with_contraction</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">shortest_paths</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{1: {1: 0,
  2: 1,
  3: 4,
  4: 3,
  5: 8,
  6: 6,
  7: 6,
  8: 5,
  9: 5,
  10: 8,
  11: 9,
  12: 6,
  13: 5,
  14: 3},
 2: {1: 1,
  2: 0,
  3: 4,
  4: 2,
  5: 7,
  6: 6,
  7: 6,
  8: 5,
  9: 5,
  10: 8,
  11: 9,
  12: 6,
  13: 6,
  14: 4},
 3: {1: 4,
  2: 4,
  3: 0,
  4: 2,
  5: 5,
  6: 2,
  7: 2,
  8: 1,
  9: 1,
  10: 4,
  11: 5,
  12: 2,
  13: 4,
  14: 6},
 4: {1: 3,
  2: 2,
  3: 2,
  4: 0,
  5: 5,
  6: 4,
  7: 4,
  8: 3,
  9: 3,
  10: 6,
  11: 7,
  12: 4,
  13: 6,
  14: 6},
 5: {1: 8,
  2: 7,
  3: 5,
  4: 5,
  5: 0,
  6: 3,
  7: 7,
  8: 6,
  9: 4,
  10: 6,
  11: 8,
  12: 5,
  13: 7,
  14: 9},
 6: {1: 6,
  2: 6,
  3: 2,
  4: 4,
  5: 3,
  6: 0,
  7: 4,
  8: 3,
  9: 1,
  10: 3,
  11: 5,
  12: 2,
  13: 4,
  14: 6},
 7: {1: 6,
  2: 6,
  3: 2,
  4: 4,
  5: 7,
  6: 4,
  7: 0,
  8: 3,
  9: 3,
  10: 6,
  11: 7,
  12: 4,
  13: 6,
  14: 8},
 8: {1: 5,
  2: 5,
  3: 1,
  4: 3,
  5: 6,
  6: 3,
  7: 3,
  8: 0,
  9: 2,
  10: 5,
  11: 6,
  12: 3,
  13: 5,
  14: 7},
 9: {1: 5,
  2: 5,
  3: 1,
  4: 3,
  5: 4,
  6: 1,
  7: 3,
  8: 2,
  9: 0,
  10: 3,
  11: 4,
  12: 1,
  13: 3,
  14: 5},
 10: {1: 8,
  2: 8,
  3: 4,
  4: 6,
  5: 6,
  6: 3,
  7: 6,
  8: 5,
  9: 3,
  10: 0,
  11: 4,
  12: 4,
  13: 6,
  14: 8},
 11: {1: 9,
  2: 9,
  3: 5,
  4: 7,
  5: 8,
  6: 5,
  7: 7,
  8: 6,
  9: 4,
  10: 4,
  11: 0,
  12: 3,
  13: 4,
  14: 6},
 12: {1: 6,
  2: 6,
  3: 2,
  4: 4,
  5: 5,
  6: 2,
  7: 4,
  8: 3,
  9: 1,
  10: 4,
  11: 3,
  12: 0,
  13: 2,
  14: 4},
 13: {1: 5,
  2: 6,
  3: 4,
  4: 6,
  5: 7,
  6: 4,
  7: 6,
  8: 5,
  9: 3,
  10: 6,
  11: 4,
  12: 2,
  13: 0,
  14: 2},
 14: {1: 3,
  2: 4,
  3: 6,
  4: 6,
  5: 9,
  6: 6,
  7: 8,
  8: 7,
  9: 5,
  10: 8,
  11: 6,
  12: 4,
  13: 2,
  14: 0}}
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="how-to-choose-the-order-of-contraction">
<h2>How to choose the order of contraction<a class="headerlink" href="#how-to-choose-the-order-of-contraction" title="Permalink to this headline">¶</a></h2>
<p>By calculating the edge difference of the nodes which equals to <span class="math notranslate nohighlight">\(S - E\)</span>; <span class="math notranslate nohighlight">\(S\)</span> is number of the added arcs to the graph if that node is contracted and <span class="math notranslate nohighlight">\(E\)</span> is the number of adjacent edges to the node that would be deleted if the node is contracted.</p>
<p>We want to contract the nodes in an ascending order of their edge difference values because if these nodes contracted first we will have to add a little number of arcs to the original graph in subsequent contractions.</p>
<p>If the number of <span class="math notranslate nohighlight">\(S\)</span> is lower than <span class="math notranslate nohighlight">\(E\)</span>, that means when contracted we won’t add as many edges to the graph as we have deleted already, SO when we contract later nodes we will have more pruned graph and we would have to add less and less arcs in subsequent contractions.</p>
<p>Think about it yourself, you will find that the nodes with the lowest ED are on “edge” of the graph not central nodes, which leads to small number of arcs to be added after contracting them and when we get to the contraction of central nodes we have already contracted most of the nodes of the graph so we don’t need to add as many arcs as we would have added if these central nodes have been contracted before “edge” nodes.</p>
</div>
</div>
<div class="section" id="calculating-ed">
<h1>Calculating ED<a class="headerlink" href="#calculating-ed" title="Permalink to this headline">¶</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calculate_edge_difference</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">shortest_paths</span><span class="p">):</span>
    <span class="n">edge_difference</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">seenBefore</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="c1"># used in edge difference calculations</span>
        <span class="n">edges_incident</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># we will be deleting the node entry</span>
        <span class="c1"># from the original shortest paths</span>
        <span class="c1"># dictionary so we need to save its state</span>
        <span class="c1"># for later iterations</span>
        <span class="n">contracted_node_paths</span> <span class="o">=</span> <span class="n">shortest_paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">shortest_paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="c1"># excluding the node that we have just contracted</span>
        <span class="n">new_graph</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span> 
        <span class="n">new_graph</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        
        <span class="c1"># let&#39;s compute the new shortest paths between</span>
        <span class="c1"># the nodes of the graph without the contracted</span>
        <span class="c1"># node so we can see the changes and add arcs </span>
        <span class="c1"># to the graph accordingly but that is in</span>
        <span class="c1"># the algorithm itself </span>
        <span class="n">new_shortest_paths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">new_graph</span><span class="p">:</span>
            <span class="n">new_shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">new_graph</span><span class="p">:</span>
                <span class="c1"># path the contracted node &quot;i&quot; to compute new shortest paths accordingly</span>
                <span class="n">new_shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="n">destination</span><span class="p">]</span> <span class="o">=</span> <span class="n">dijkstra_with_contraction</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> \
                                                                                    <span class="n">source</span><span class="p">,</span> \
                                                                                    <span class="n">destination</span><span class="p">,</span> \
                                                                                    <span class="n">contracted</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span>
        <span class="c1"># the add arcs to keep the graph all pairs shortest paths invariant</span>
        <span class="n">shortcuts</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">new_shortest_paths</span><span class="p">:</span>
            <span class="c1"># we get a copy from the original and the new shortest paths dictionary</span>
            <span class="n">SP_contracted</span> <span class="o">=</span> <span class="n">new_shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
            <span class="n">SP_original</span> <span class="o">=</span> <span class="n">shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">SP_contracted</span><span class="p">:</span>
                <span class="c1"># this is statement so we don&#39;t add 2 arcs</span>
                <span class="c1"># for the same pair of nodes </span>
                <span class="k">if</span> <span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">]</span> <span class="ow">in</span> <span class="n">seenBefore</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">seenBefore</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">source</span><span class="p">,</span><span class="n">destination</span><span class="p">)))</span>
                
                <span class="c1"># if there is a difference between the original SP and</span>
                <span class="c1"># post-contraction SP -- just add new arc</span>
                <span class="k">if</span> <span class="n">SP_contracted</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span> <span class="o">!=</span> <span class="n">SP_original</span><span class="p">[</span><span class="n">destination</span><span class="p">]:</span>
                    <span class="n">shortcuts</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># let&#39;s leave the dictionary as we took it </span>
        <span class="c1"># from the last iteration</span>
        <span class="n">shortest_paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">contracted_node_paths</span>
        
        <span class="c1"># this is the value of the contraction</span>
        <span class="c1"># heuristic for that node</span>
        <span class="n">ED</span> <span class="o">=</span> <span class="n">shortcuts</span> <span class="o">-</span> <span class="n">edges_incident</span>
        <span class="n">edge_difference</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">ED</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">edge_difference</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">edge_difference</span> <span class="o">=</span> <span class="n">calculate_edge_difference</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">shortest_paths</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># sort by the ED heuristic value</span>
<span class="c1"># so we can contract them in the same</span>
<span class="c1"># order as in this list</span>
<span class="n">edge_difference</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">pair</span> <span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">edge_difference</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(8, -5),
 (10, -4),
 (5, -3),
 (7, -3),
 (11, -3),
 (14, 0),
 (2, 2),
 (1, 3),
 (6, 4),
 (13, 5),
 (4, 7),
 (12, 18),
 (3, 26),
 (9, 33)]
</pre></div>
</div>
</div>
</div>
<p>We have now computed the ED value for each node when it is the only node contracted in the graph, but in the algorithm itself we contract the nodes successively so these values we have generated won’t be valid and reflecting the then current state of the graph possibly after the first iteration of the algorithm.</p>
<p>But as you remember from the introduction, that any arbitrary order of nodes contraction is valid and will lead to the correct answer eventually.</p>
<p>We could update the edge difference list at each iteration, which would be expensive for large graphs or select some nodes to update their ED value like the adjacent nodes of the current contracted node. After re-ordering the list of the node we continue our algorithm. There is a number of heuristics that update the order of contraction in the paper introducing the algorithm.</p>
<hr class="docutils" />
<p>We will contract nodes according to the order of edge_difference list which would give us good enough preformance for the current problem.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># to keep track of the edges added after the algorithm finishes</span>
<span class="n">edges_before</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">current_graph</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>

<span class="c1"># iterating over the tuples (node, level)</span>
<span class="c1"># from the sorted edge difference list</span>

<span class="k">for</span> <span class="n">node_ED</span> <span class="ow">in</span> <span class="n">edge_difference</span><span class="p">:</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">node_ED</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># now we will contract the given node through all iterations</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span> <span class="s1">&#39;contracted&#39;</span><span class="p">)</span>
    
    <span class="c1"># we have already contracted the node</span>
    <span class="c1"># so there is no need </span>
    <span class="n">new_graph</span> <span class="o">=</span> <span class="n">current_graph</span>
    <span class="n">new_graph</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="n">current_shortest_paths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">new_graph</span><span class="p">:</span>
            <span class="n">current_shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">new_graph</span><span class="p">:</span>
                <span class="n">current_shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="n">destination</span><span class="p">]</span> <span class="o">=</span> <span class="n">dijkstra_with_contraction</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> \
                                                                                    <span class="n">source</span><span class="p">,</span> \
                                                                                    <span class="n">destination</span><span class="p">)</span>
                
    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">current_shortest_paths</span><span class="p">:</span>
        <span class="n">SP_contracted</span> <span class="o">=</span> <span class="n">current_shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="n">SP_original</span> <span class="o">=</span> <span class="n">shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">SP_contracted</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">SP_contracted</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span> <span class="o">!=</span> <span class="n">SP_original</span><span class="p">[</span><span class="n">destination</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;we have added edge between &quot;</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span><span class="s2">&quot; after contracting&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                
                <span class="c1"># it seems like we add two edges instead of one, but this is simple graph</span>
                <span class="c1"># so adding edge from a to b and then adding edge from b to a are the same</span>
                <span class="c1"># doesn&#39;t add a thing, we didn&#39;t include condition for that because it will</span>
                <span class="c1"># complicate the algorithm</span>
                
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">SP_original</span><span class="p">[</span><span class="n">destination</span><span class="p">])</span>
                
    
    <span class="n">current_graph</span> <span class="o">=</span> <span class="n">new_graph</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>we have added edge between  1 13  after contracting 14
we have added edge between  2 13  after contracting 14
we have added edge between  13 1  after contracting 14
we have added edge between  13 2  after contracting 14
we have added edge between  1 4  after contracting 2
we have added edge between  4 1  after contracting 2
</pre></div>
</div>
</div>
</div>
<p>new edges set after adding the additional arcs</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">edges_after</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# edges before&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_before</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# edges after&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_after</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span># edges before 26
# edges after 29
</pre></div>
</div>
</div>
</div>
<p>Let’s see what are these edges</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">added_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">edges_after</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">edges_before</span><span class="p">))</span>
<span class="n">added_edges</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(1, 13), (2, 13), (1, 4)]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># let&#39;s color these edges and draw the graph again</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span> <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">added_edges</span> <span class="k">else</span> <span class="s1">&#39;k&#39;</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span> 
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">colors</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph_search_algorithms_70_0.png" src="../../_images/graph_search_algorithms_70_0.png" />
</div>
</div>
<p>After we have added the new edges we need to do dijkstra from source and dijkstra from destination, according to the <strong>upward</strong> and <strong>downward</strong> graph policy we talked about in the introduction.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># which is the same as edge_difference</span>
<span class="c1"># list because we didn&#39;t use any update heuristic</span>
<span class="n">hierarchical_order</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="k">for</span> <span class="n">order</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edge_difference</span><span class="p">):</span>
    <span class="n">hierarchical_order</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">order</span>
</pre></div>
</div>
</div>
</div>
<p>dictionary of nodes and its level of hierarchy</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hierarchical_order</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{8: 0,
 10: 1,
 5: 2,
 7: 3,
 11: 4,
 14: 5,
 2: 6,
 1: 7,
 6: 8,
 13: 9,
 4: 10,
 12: 11,
 3: 12,
 9: 13}
</pre></div>
</div>
</div>
</div>
<p>let’s solve our problem with source node to be 8 and target node to be 12</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">source</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">destination</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="dijkstra-from-source">
<h1>Dijkstra From Source<a class="headerlink" href="#dijkstra-from-source" title="Permalink to this headline">¶</a></h1>
<p><strong>upward graph</strong></p>
<p>We will do the normal dijkstra algorithm with our origin to be <span class="math notranslate nohighlight">\(8\)</span> but with one restriction, that we don’t visit children of the relaxed node with lower level of hierarchy than their parent.</p>
<p>So if we have relaxed node number <span class="math notranslate nohighlight">\(13\)</span> we can’t relax the edge between node <span class="math notranslate nohighlight">\(13\)</span> and node <span class="math notranslate nohighlight">\(11\)</span> because the level of node <span class="math notranslate nohighlight">\(13\)</span> is higher.</p>
<p>This is the pruning we talked about and it gave us the correct answer at the end.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># initializing </span>
<span class="n">SP_s</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">parent_s</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">unrelaxed_s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
    <span class="n">SP_s</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">parent_s</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">unrelaxed_s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="n">SP_s</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># dijkstra</span>
<span class="k">while</span> <span class="n">unrelaxed_s</span><span class="p">:</span>
    <span class="n">node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">unrelaxed_s</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
    <span class="n">unrelaxed_s</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span> <span class="k">break</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
        <span class="c1"># skip unqualified edges</span>
        <span class="k">if</span> <span class="n">hierarchical_order</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">hierarchical_order</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span> <span class="k">continue</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">child</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">child</span><span class="p">]:</span>
            <span class="n">SP_s</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
            <span class="n">parent_s</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">SP_s</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{1: inf,
 2: inf,
 3: 1,
 4: inf,
 5: inf,
 6: 3,
 7: 6,
 8: 0,
 9: 2,
 10: inf,
 11: inf,
 12: 7,
 13: 5,
 14: inf}
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="dijkstra-from-target">
<h1>Dijkstra From Target<a class="headerlink" href="#dijkstra-from-target" title="Permalink to this headline">¶</a></h1>
<p><strong>downward graph</strong></p>
<p>Same idea as upward graph dijkstra but you don’t relax an edge between a parent and child with higher hierarchy.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># initializing </span>
<span class="n">SP_t</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">parent_t</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">unrelaxed_t</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
    <span class="n">SP_t</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">parent_t</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">unrelaxed_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="n">SP_t</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># dijkstra</span>
<span class="k">while</span> <span class="n">unrelaxed_t</span><span class="p">:</span>
    <span class="n">node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">unrelaxed_t</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
    <span class="n">unrelaxed_t</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span> <span class="k">break</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
        <span class="c1"># skip unqualified edges</span>
        <span class="k">if</span> <span class="n">hierarchical_order</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">hierarchical_order</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span> <span class="k">continue</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">child</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">child</span><span class="p">]:</span>
            <span class="n">SP_t</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
            <span class="n">parent_t</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">SP_t</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{1: inf,
 2: inf,
 3: inf,
 4: inf,
 5: inf,
 6: inf,
 7: inf,
 8: inf,
 9: 1,
 10: inf,
 11: inf,
 12: 0,
 13: inf,
 14: inf}
</pre></div>
</div>
</div>
</div>
<p>We need to merge the common settled nodes from both <code class="docutils literal notranslate"><span class="pre">SP_d</span></code> and <code class="docutils literal notranslate"><span class="pre">SP_s</span></code> and see the minimum summation of value and that is our shortest path like in bi-directional search and collusion between front expansion and back expansion.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">minimum</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
<span class="n">merge_node</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">SP_s</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span> <span class="k">continue</span>
    <span class="k">if</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minimum</span><span class="p">:</span>
        <span class="n">minimum</span> <span class="o">=</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">merge_node</span> <span class="o">=</span> <span class="n">i</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">minimum</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">merge_node</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>9
</pre></div>
</div>
</div>
</div>
<p>very small utility to see the route from origin of dijkstra to a given node</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">route_dijkstra</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="n">route</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">node</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">route</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">route</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">route_from_target</span> <span class="o">=</span> <span class="n">route_dijkstra</span><span class="p">(</span><span class="n">parent_t</span><span class="p">,</span> <span class="n">merge_node</span><span class="p">)</span>
<span class="n">route_from_target</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[12, 9]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">route_from_source</span> <span class="o">=</span> <span class="n">route_dijkstra</span><span class="p">(</span><span class="n">parent_s</span><span class="p">,</span> <span class="n">merge_node</span><span class="p">)</span>
<span class="n">route_from_source</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[8, 3, 9]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">route</span> <span class="o">=</span> <span class="n">route_from_source</span> <span class="o">+</span> <span class="n">route_from_target</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">route</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[8, 3, 9, 12]
</pre></div>
</div>
</div>
</div>
<p>let’s use networkx algorithm to see if that is true or not</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">networkx.algorithms.shortest_paths.weighted</span> <span class="kn">import</span> <span class="n">single_source_dijkstra</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">single_source_dijkstra</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(3, [8, 3, 9, 12])
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="the-pruning">
<h1>The Pruning<a class="headerlink" href="#the-pruning" title="Permalink to this headline">¶</a></h1>
<p>Let’s check once again the shortest paths list the was generated from source dijkstra and destination dijkstra</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># source dijkstra -- upward graph</span>
<span class="n">SP_s</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{1: inf,
 2: inf,
 3: 1,
 4: inf,
 5: inf,
 6: 3,
 7: 6,
 8: 0,
 9: 2,
 10: inf,
 11: inf,
 12: 7,
 13: 5,
 14: inf}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># target dijkstra -- downward graph</span>
<span class="n">SP_t</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{1: inf,
 2: inf,
 3: inf,
 4: inf,
 5: inf,
 6: inf,
 7: inf,
 8: inf,
 9: 1,
 10: inf,
 11: inf,
 12: 0,
 13: inf,
 14: inf}
</pre></div>
</div>
</div>
</div>
<p>The nodes that were ignored in the search because of its hierarchy level has shortest path of <code class="docutils literal notranslate"><span class="pre">inf</span></code>, these nodes were pruned from our search space.</p>
<p>Let’s count the nodes that were untouched from both dijkstra.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">unvisited</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">s_node</span><span class="p">,</span> <span class="n">s_dist</span> <span class="ow">in</span> <span class="n">SP_s</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">t_node</span><span class="p">,</span> <span class="n">t_dist</span> <span class="ow">in</span> <span class="n">SP_t</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">s_node</span> <span class="o">==</span> <span class="n">t_node</span> <span class="ow">and</span> <span class="n">s_dist</span> <span class="o">==</span> <span class="n">t_dist</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="n">unvisited</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;we have skipped </span><span class="si">{</span><span class="n">unvisited</span><span class="si">}</span><span class="s2"> nodes from a graph with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span>
<span class="s2">so we have skipped </span><span class="si">{</span><span class="n">unvisited</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s2">% of the nodes in our search space.&quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>we have skipped 7 nodes from a graph with 14, 
so we have skipped 50.0% of the nodes in our search space.
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="notes-for-implementation">
<h1>Notes for implementation<a class="headerlink" href="#notes-for-implementation" title="Permalink to this headline">¶</a></h1>
<ol class="simple">
<li><p>You don’t need to use dijkstra for calculating SP, we only used it because we are working on a simple graph. If you are on a situation where you are dealing with a graph with negative cycles or self-loops or some other property where Dijkstra breaks down. You just need to use the appropriate algorithm for SP, but you need to enforce the policy of upward/downward graph in the algorithm itself.</p></li>
<li><p>Sometimes the path returned by merging both dijkstra would contain an edge that was added in the contraction phase, in that case you just replace that edge with the next shortest path from nodes incident to that edge.</p></li>
</ol>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./content/test"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Alaa Khamis and Yinan Wang<br/>
        
            &copy; Copyright 2021.<br/>
          <div class="extra_footer">
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">
<img alt="Creative Commons Licence" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a>
<span>This work is licensed under a 
<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.</span>

          </div>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>