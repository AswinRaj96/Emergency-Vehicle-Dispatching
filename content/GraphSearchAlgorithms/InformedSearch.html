<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Informed Search Algorithms — AI Search Algorithms for Smart Mobility</title>
<link href="../../_static/css/theme.css" rel="stylesheet"/>
<link href="../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet"/>
<link href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css" rel="stylesheet"/>
<link as="font" crossorigin="" href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2" rel="preload" type="font/woff2"/>
<link as="font" crossorigin="" href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2" rel="preload" type="font/woff2"/>
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/sphinx-book-theme.5f77b4aec8189eecf79907ce328c390d.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/togglebutton.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/copybutton.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/mystnb.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/sphinx-thebe.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" rel="stylesheet" type="text/css"/>
<link as="script" href="../../_static/js/index.1c5a1a01449ed65a7b51.js" rel="preload"/>
<script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
<script src="../../_static/jquery.js"></script>
<script src="../../_static/underscore.js"></script>
<script src="../../_static/doctools.js"></script>
<script src="../../_static/togglebutton.js"></script>
<script src="../../_static/clipboard.min.js"></script>
<script src="../../_static/copybutton.js"></script>
<script src="../../_static/tabs.js"></script>
<script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
<script src="../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
<script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
<script async="async" src="https://unpkg.com/thebe@latest/lib/index.js"></script>
<script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
<script async="async" src="../../_static/sphinx-thebe.js"></script>
<script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
<link href="../../genindex.html" rel="index" title="Index"/>
<link href="../../search.html" rel="search" title="Search"/>
<link href="SearchComparison.html" rel="next" title="Search Algorithm Comparison"/>
<link href="BlindSearch.html" rel="prev" title="Blind Search Algorithms"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="en" name="docsearch:language"/>
</head>
<body data-offset="80" data-spy="scroll" data-target="#bd-toc-nav">
<div class="container-fluid" id="banner"></div>
<div class="container-xl">
<div class="row">
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
<div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../index.html">
<img alt="logo" class="logo" src="../../_static/sm.png"/>
<h1 class="site-logo" id="site-title">AI Search Algorithms for Smart Mobility</h1>
</a>
</div><form action="../../search.html" class="bd-search d-flex align-items-center" method="get">
<i class="icon fas fa-search"></i>
<input aria-label="Search this book..." autocomplete="off" class="form-control" id="search-input" name="q" placeholder="Search this book..." type="search"/>
</form><nav aria-label="Main navigation" class="bd-links" id="bd-docs-nav">
<div class="bd-toc-item active">
<ul class="nav bd-sidenav">
<li class="toctree-l1">
<a class="reference internal" href="../../index.html">
   AI Search Algorithms for Smart Mobility
  </a>
</li>
</ul>
<ul class="current nav bd-sidenav">
<li class="toctree-l1">
<a class="reference internal" href="../GettingStarted/index.html">
   Getting Started
  </a>
</li>
<li class="toctree-l1 has-children">
<a class="reference internal" href="../IntroGeoScience/index.html">
   Introduction to Geospatial Data Science
  </a>
<input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
<label for="toctree-checkbox-1">
<i class="fas fa-chevron-down">
</i>
</label>
<ul>
<li class="toctree-l2">
<a class="reference internal" href="../IntroGeoScience/SpatialData.html">
     Spatial Data
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="../IntroGeoScience/Projection.html">
     Projection
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="../IntroGeoScience/Visualization.html">
     Visualization
    </a>
</li>
</ul>
</li>
<li class="toctree-l1 current active has-children">
<a class="reference internal" href="index.html">
   Graph Search Algorithms
  </a>
<input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
<label for="toctree-checkbox-2">
<i class="fas fa-chevron-down">
</i>
</label>
<ul class="current">
<li class="toctree-l2">
<a class="reference internal" href="RoadGraph.html">
     From Road Network to Graph
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="GraphSearch.html">
     Graph Search
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="BlindSearch.html">
     Blind Search Algorithms
    </a>
</li>
<li class="toctree-l2 current active">
<a class="current reference internal" href="#">
     Informed Search Algorithms
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="SearchComparison.html">
     Search Algorithm Comparison
    </a>
</li>
</ul>
</li>
<li class="toctree-l1 has-children">
<a class="reference internal" href="../TrajectoryAlgorithms/index.html">
   Trajectory-based Algorithms
  </a>
<input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
<label for="toctree-checkbox-3">
<i class="fas fa-chevron-down">
</i>
</label>
<ul>
<li class="toctree-l2">
<a class="reference internal" href="../TrajectoryAlgorithms/TabuSearch.html">
     Tabu Search
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="../TrajectoryAlgorithms/SimulatedAnnealing.html">
     Simulated Annealing
    </a>
</li>
</ul>
</li>
<li class="toctree-l1 has-children">
<a class="reference internal" href="../EvolutionaryComputingAlgorithms/index.html">
   Evolutionary Computing Algorithms
  </a>
<input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
<label for="toctree-checkbox-4">
<i class="fas fa-chevron-down">
</i>
</label>
<ul>
<li class="toctree-l2">
<a class="reference internal" href="../EvolutionaryComputingAlgorithms/GeneticAlgorithms.html">
     Genetic Algorithms
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="../EvolutionaryComputingAlgorithms/DifferentialEvolution.html">
     Differential Evolution
    </a>
</li>
</ul>
</li>
<li class="toctree-l1 has-children">
<a class="reference internal" href="../SwarmIntelligenceAlgorithms/index.html">
   Swarm Intelligence Algorithms
  </a>
<input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
<label for="toctree-checkbox-5">
<i class="fas fa-chevron-down">
</i>
</label>
<ul>
<li class="toctree-l2">
<a class="reference internal" href="../SwarmIntelligenceAlgorithms/ParticleSwarmOptimization.html">
     Particle Swarm Optimization
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="../SwarmIntelligenceAlgorithms/AntColonyOptimization.html">
     Ant Colony Optimization
    </a>
</li>
</ul>
</li>
<li class="toctree-l1 has-children">
<a class="reference internal" href="../LearnToSearch/index.html">
   Learn to Search
  </a>
<input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
<label for="toctree-checkbox-6">
<i class="fas fa-chevron-down">
</i>
</label>
<ul>
<li class="toctree-l2">
<a class="reference internal" href="../LearnToSearch/GraphNeuralNetworks.html">
     Graph Neural Networks (GNN)
    </a>
</li>
<li class="toctree-l2">
<a class="reference internal" href="../LearnToSearch/ReinforcementLearning.html">
     Reinforcement Learning
    </a>
</li>
</ul>
</li>
<li class="toctree-l1 has-children">
<a class="reference internal" href="../PeopleMobilityProblems/index.html">
   People Mobility Problems
  </a>
<input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
<label for="toctree-checkbox-7">
<i class="fas fa-chevron-down">
</i>
</label>
<ul>
<li class="toctree-l2">
<a class="reference internal" href="../PeopleMobilityProblems/Maven.html">
     Maven Car-Sharing Service
    </a>
</li>
</ul>
</li>
<li class="toctree-l1">
<a class="reference internal" href="../LogisticsProblems.html">
   Logistics Problems
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="../InfrastructureProblems.html">
   Infrastructure Problems
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="../ToolsAndPythonLibraries/index.html">
   Tools and Python Libraries
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="../Datasets.html">
   Datasets
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="../../References.html">
   References
  </a>
</li>
</ul>
</div>
</nav> <!-- To handle the deprecated key -->
<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>
</div>
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
<div class="topbar container-xl fixed-top">
<div class="topbar-contents row">
<div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
<div class="col pl-md-4 topbar-main">
<button aria-controls="navbar-menu" aria-expanded="true" aria-label="Toggle navigation" class="navbar-toggler ml-0" data-placement="bottom" data-target=".site-navigation" data-toggle="collapse" id="navbar-toggler" title="Toggle navigation" type="button">
<i class="fas fa-bars"></i>
<i class="fas fa-arrow-left"></i>
<i class="fas fa-arrow-up"></i>
</button>
<div class="dropdown-buttons-trigger">
<button aria-label="Download this page" class="btn btn-secondary topbarbtn" id="dropdown-buttons-trigger"><i class="fas fa-download"></i></button>
<div class="dropdown-buttons">
<!-- ipynb file if we had a myst markdown file -->
<!-- Download raw file -->
<a class="dropdown-buttons" href="../../_sources/content/GraphSearchAlgorithms/InformedSearch.ipynb"><button class="btn btn-secondary topbarbtn" data-placement="left" data-toggle="tooltip" title="Download source file" type="button">.ipynb</button></a>
<!-- Download PDF via print -->
<button class="btn btn-secondary topbarbtn" data-placement="left" data-toggle="tooltip" id="download-print" onclick="window.print()" title="Print to PDF" type="button">.pdf</button>
</div>
</div>
<!-- Source interaction buttons -->
<div class="dropdown-buttons-trigger">
<button aria-label="Connect with source repository" class="btn btn-secondary topbarbtn" id="dropdown-buttons-trigger"><i class="fab fa-github"></i></button>
<div class="dropdown-buttons sourcebuttons">
<a class="repository-button" href="https://github.com/SmartMobilityAlgorithms/book"><button class="btn btn-secondary topbarbtn" data-placement="left" data-toggle="tooltip" title="Source repository" type="button"><i class="fab fa-github"></i>repository</button></a>
</div>
</div>
<!-- Full screen (wrap in <a> to have style consistency -->
<a class="full-screen-button"><button aria-label="Fullscreen mode" class="btn btn-secondary topbarbtn" data-placement="bottom" data-toggle="tooltip" onclick="toggleFullScreen()" title="Fullscreen mode" type="button"><i class="fas fa-expand"></i></button></a>
<!-- Launch buttons -->
<div class="dropdown-buttons-trigger">
<button aria-label="Launch interactive content" class="btn btn-secondary topbarbtn" id="dropdown-buttons-trigger"><i class="fas fa-rocket"></i></button>
<div class="dropdown-buttons">
<a class="binder-button" href="https://mybinder.org/v2/gh/SmartMobilityAlgorithms/book/main?urlpath=tree/content/GraphSearchAlgorithms/InformedSearch.ipynb"><button class="btn btn-secondary topbarbtn" data-placement="left" data-toggle="tooltip" title="Launch Binder" type="button"><img alt="Interact on binder" class="binder-button-logo" src="../../_static/images/logo_binder.svg"/>Binder</button></a>
</div>
</div>
</div>
<!-- Table of contents -->
<div class="d-none d-md-block col-md-2 bd-toc show">
<div class="tocsection onthispage pt-5 pb-3">
<i class="fas fa-list"></i> Contents
            </div>
<nav id="bd-toc-nav">
<ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#minimum-spanning-tree">
   Minimum Spanning Tree
  </a>
<ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#disjoint-sets">
     Disjoint Sets
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#parent-array">
     Parent Array
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#find-algorithm">
     Find Algorithm
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#minimum-spanning-tree-with-kruskal-s-algorithm">
     Minimum Spanning Tree with Kruskal’s algorithm
    </a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#hill-climbing">
   Hill Climbing
  </a>
<ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#the-function">
     The function
    </a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#beam-search">
   Beam Search
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#a-search">
   A* Search
  </a>
<ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#the-heuristic">
     The Heuristic
    </a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#bi-directional-search">
   Bi-Directional Search
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#hierarchical-approaches">
   Hierarchical Approaches
  </a>
<ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#highway-hierarchies">
     Highway Hierarchies
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#contraction-hierarchies">
     Contraction Hierarchies
    </a>
<ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry">
<a class="reference internal nav-link" href="#contraction">
       Contraction
      </a>
</li>
<li class="toc-h4 nav-item toc-entry">
<a class="reference internal nav-link" href="#contraction-order">
       Contraction Order
      </a>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#example-1-bi-directional-dijkstra-with-contraction">
     Example #1: Bi-directional Dijkstra with contraction
    </a>
<ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry">
<a class="reference internal nav-link" href="#pruning">
       Pruning
      </a>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#example-2-equestrian-statue-to-bahen-centre-using-contraction-hierarchy">
     Example #2: Equestrian Statue to Bahen Centre using Contraction Hierarchy
    </a>
</li>
</ul>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="row" id="main-content">
<div class="col-12 col-md-9 pl-md-3 pr-md-0">
<div>
<div class="section" id="informed-search-algorithms">
<h1>Informed Search Algorithms<a class="headerlink" href="#informed-search-algorithms" title="Permalink to this headline">¶</a></h1>
<p>Informed search algorithms differ from blind search algorithms in the sense that the goal state is already known. Additionally, the algorithms use knowledge during the search in order to guide the search. This knowledge can take the form of distance to target, or incurred costs.</p>
<hr class="docutils"/>
<div class="section" id="minimum-spanning-tree">
<h2>Minimum Spanning Tree<a class="headerlink" href="#minimum-spanning-tree" title="Permalink to this headline">¶</a></h2>
<p>Given a spanning tree <span class="math notranslate nohighlight">\(T\)</span> in a graph <span class="math notranslate nohighlight">\(G\)</span> with a weight <span class="math notranslate nohighlight">\(w\)</span> and edges <span class="math notranslate nohighlight">\(E\)</span>, the weight <span class="math notranslate nohighlight">\(w\)</span> of <span class="math notranslate nohighlight">\(T\)</span> is the sum of weights of its edges. If <span class="math notranslate nohighlight">\(T\)</span> has the minimum weight over all spanning trees of <span class="math notranslate nohighlight">\(G\)</span>, we call <span class="math notranslate nohighlight">\(T\)</span> a <em>minimum spanning tree</em>.</p>
<div class="section" id="disjoint-sets">
<h3>Disjoint Sets<a class="headerlink" href="#disjoint-sets" title="Permalink to this headline">¶</a></h3>
<p>Before going any further and introducing the algorithm that generates the minimum spanning <span class="math notranslate nohighlight">\(T\)</span> given a graph <span class="math notranslate nohighlight">\(G\)</span>, we need to discuss disjoint sets, like set of vertices <span class="math notranslate nohighlight">\(V\)</span>. The main operations on disjoint sets which are interesting to us are <strong>finding</strong> the set containing a given element and forming the <strong>union</strong> of two sets, like having multiple sets of vertices of different spanning trees.</p>
</div>
<div class="section" id="parent-array">
<h3>Parent Array<a class="headerlink" href="#parent-array" title="Permalink to this headline">¶</a></h3>
<p>Let’s consider a  set <span class="math notranslate nohighlight">\(S\)</span> which contains all <span class="math notranslate nohighlight">\(n = 12\)</span> vertices of a graph, so <span class="math notranslate nohighlight">\(S = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\}\)</span>. If we want to partition them into five sets for further processing, into <span class="math notranslate nohighlight">\(k = 5\)</span> <em>disjoint</em> sets, imagine that these disjoint sets represent a single spanning tree in the graph. The vertices set would be <span class="math notranslate nohighlight">\(S = \{\{0, 1, 2\}, \{3, 4\}, \{5, 6, 7, 8\}, \{9, 10\}, \{11\}\}\)</span>. We need to be quick in maintaining these sets, so we need to refer to each set by the root of the given disjoint set (root of the tree).</p>
<p>Here we introduce the idea of maintaining a parent array that stores the parent of each element (node). The root won’t have a parent so its value in the parent array would be <span class="math notranslate nohighlight">\(-1\)</span>. Here is an example of the set above, think about them as trees in the graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">figures</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">disjoint_forest</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/InformedSearch_4_0.png" src="../../_images/InformedSearch_4_0.png"/>
</div>
</div>
<p>For <span class="math notranslate nohighlight">\(V[i], i = 0,1,2, ... , 11\)</span>
$<span class="math notranslate nohighlight">\(V[i]      =  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\)</span><span class="math notranslate nohighlight">\(
\)</span><span class="math notranslate nohighlight">\(Parent[i] =  [-1, 0, 0, -1, 3, -1, 5, 5, 5, 10, -1, -1]\)</span>$</p>
<p>So now we have a forest <span class="math notranslate nohighlight">\(F\)</span> from the set of vertices <span class="math notranslate nohighlight">\(S\)</span> and in <span class="math notranslate nohighlight">\(F\)</span>/<span class="math notranslate nohighlight">\(S\)</span> we have multiple trees/disjoint sets…</p>
</div>
<div class="section" id="find-algorithm">
<h3>Find Algorithm<a class="headerlink" href="#find-algorithm" title="Permalink to this headline">¶</a></h3>
<p>Given a vertex <span class="math notranslate nohighlight">\(i\)</span> in a certain tree/disjoint set, we want to know the root of that tree.</p>
<p><strong>FIND</strong>(Parent[0:n-1], i, r) <strong>returns</strong> The root (<em>r</em>) of disjoint set that contains V[i]<br/>
 <em>r</em> ← <em>V[i]</em></p>
<p> <strong>while</strong> Parent[<em>r</em>] &gt;= 0 <strong>do</strong></p>
<p>  <em>r</em> ← Parent[<em>r</em>]</p>
<p> <strong>endwhile</strong></p>
<p> <strong>return</strong> <em>r</em></p>
</div>
<div class="section" id="minimum-spanning-tree-with-kruskal-s-algorithm">
<h3>Minimum Spanning Tree with Kruskal’s algorithm<a class="headerlink" href="#minimum-spanning-tree-with-kruskal-s-algorithm" title="Permalink to this headline">¶</a></h3>
<p><strong>KRUSKAL_MST</strong>(graph) <strong>returns</strong> a set <em>MST</em> contains edges of the tree<br/>
 <em>Forest</em> ← {}<br/>
 <em>Size</em> ← 0<br/>
 <strong>for</strong> <em>i</em> ← 0 <strong>to</strong> n-1 <strong>do</strong><br/>
   <em>Parent[i]</em> ← -1<br/>
 <strong>endfor</strong><br/>
 <em>j</em> ← 0<br/>
 <strong>while</strong> <em>Size</em> &lt;= n-1 <strong>and</strong> <em>j</em> &lt; <em>m</em> <strong>do</strong> # <em>m</em> is the number of edges of set <em>E</em> = {e<sub>i</sub> = u<sub>i</sub>v<sub>i</sub> | <em>i</em> in {1,…,<em>m</em>}}<br/>
  <em>j</em> ← <em>j</em> + 1<br/>
  FIND(<em>Parent</em>[0:n-1],<em>u</em><sub>j</sub>,<em>r</em>)<br/>
  FIND(<em>Parent</em>[0:n-1],<em>v</em><sub>j</sub>,<em>s</em>)<br/>
  <strong>if</strong> <em>r</em> ≠ <em>s</em> <strong>then</strong><br/>
   <em>Forest</em> ← <em>Forest</em> ∐ {<em>e</em><sub>j</sub>}<br/>
   <em>Size</em> ← <em>Size</em> + 1<br/>
   UNION(<em>Parent</em> [0:n-1],<em>r</em>,<em>s</em>)<br/>
  <strong>endif</strong>
 <strong>endwhile</strong>
 <em>MST</em> ← <em>Forest</em><br/>
 <strong>return</strong> <em>MST</em></p>
<p>Let’s find the MST for all nodes in our search space (surrounding the University of Toronto).
Here are some things to keep in mind:</p>
<ul class="simple">
<li><p>The graph may seem like a one big connected component but it actually isn’t. There are one-way streets which seem to connect the adjacent nodes on the graph, but in reality they are not connected (you can go from A to B but not in reverse).</p></li>
<li><p>This will result in multiple MST at the end of the algorithm, one for each connected component.</p></li>
<li><p>There may appear to loops in the MST, which is a major violation of tree-like structures. Recall however that what may seem like loops may just be one-way streets.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span>
<span class="kn">import</span> <span class="nn">osmnx</span>
<span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">LineCollection</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">smart_mobility_utilities.problem</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">PriorityQueue</span>

<span class="n">reference</span> <span class="o">=</span> <span class="p">(</span><span class="mf">43.661667</span><span class="p">,</span> <span class="o">-</span><span class="mf">79.395</span><span class="p">)</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">osmnx</span><span class="o">.</span><span class="n">graph_from_point</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">clean_periphery</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">network_type</span><span class="o">=</span><span class="s1">'drive_service'</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">osmnx</span><span class="o">.</span><span class="n">plot_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/InformedSearch_12_0.png" src="../../_images/InformedSearch_12_0.png"/>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Collect x,y coordinates for each node (for visualization purposes later)</span>
<span class="n">node_Xs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s1">'x'</span><span class="p">)]</span>
<span class="n">node_Ys</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s1">'y'</span><span class="p">)]</span>

<span class="n">Edges</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">()</span>

<span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">Edges</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s1">'length'</span><span class="p">],</span><span class="n">source</span><span class="p">,</span><span class="n">destination</span><span class="p">))</span>

<span class="c1"># Disjoint set to manage loops</span>
<span class="n">nodes_set</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Edges</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
    <span class="n">nodes_set</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">nodes_set</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Returns -1 if the node has not been attached to another node during this run</span>
<span class="k">def</span> <span class="nf">find_parent</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">node</span>
    <span class="k">while</span> <span class="n">nodes_set</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">nodes_set</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># The algorithm itself:</span>
<span class="n">Forest</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">Size</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Edges</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="k">while</span> <span class="n">Size</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># the shortest edge till this point</span>
    <span class="n">edge</span> <span class="o">=</span> <span class="n">Edges</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="n">node1</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">node2</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">parent1</span> <span class="o">=</span> <span class="n">find_parent</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>
    <span class="n">parent2</span> <span class="o">=</span> <span class="n">find_parent</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">parent1</span> <span class="o">!=</span> <span class="n">parent2</span><span class="p">:</span>
        <span class="n">Forest</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        <span class="n">Size</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">nodes_set</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span> <span class="o">=</span> <span class="n">node2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Visualization</span>
<span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">Forest</span><span class="p">]</span>
<span class="n">destinations</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">Forest</span><span class="p">]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span>  <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">'w'</span><span class="p">)</span>
<span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">colorS</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">widthS</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">'geometry'</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">'geometry'</span><span class="p">]</span><span class="o">.</span><span class="n">xy</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">'x'</span><span class="p">]</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">'y'</span><span class="p">]</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">'x'</span><span class="p">]</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">'y'</span><span class="p">]</span>
            <span class="n">line</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)]</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">sources</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">destinations</span><span class="p">:</span>
            <span class="n">colorS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
            <span class="n">widthS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">2.5</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sources</span> <span class="ow">and</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">destinations</span><span class="p">:</span>
            <span class="n">colorS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
            <span class="n">widthS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">2.5</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">colorS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'r'</span><span class="p">)</span>
        <span class="n">widthS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.4</span><span class="p">)</span>    
<span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colorS</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">widthS</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>
<span class="n">scat</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">node_Xs</span><span class="p">,</span> <span class="n">node_Ys</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="s1">'k'</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/InformedSearch_16_0.png" src="../../_images/InformedSearch_16_0.png"/>
</div>
</div>
</div>
</div>
<hr class="docutils"/>
<div class="section" id="hill-climbing">
<h2>Hill Climbing<a class="headerlink" href="#hill-climbing" title="Permalink to this headline">¶</a></h2>
<p>The idea of the algorithm is quite simple:</p>
<p>Starting with a known (non-optimized) solution to a function, the algorithm checks the neighbours of that solution, and chooses the neighbour that is “more” optimized. The process is repeated until no “better” solution can be found, at which point the algorithm terminates.</p>
<p>While the algorithm works relatively well with <strong>convex</strong> problems, functions with multiple local maxima will often result in an answer that is not the global maximum. It also performs poorly when there are plateaus (a local set of solutions that are all similarly optimized).</p>
<style>
i {font-weight:normal}
span {font-weight:normal}
</style>
<div style="background-color: rgba(0,0,0,0.0470588);padding:10px;font-family:monospace;">
<b>HILL-CLIMBING</b>(<i>source</i>,<i>destination</i>) <b>return</b> a <i>route</i>
<div style="padding-left:20px;">
<i><font color="green">current</font></i> ← random <i>route</i> from <i>source</i> to <i>destination</i><br/>
<i><font color="orange">neighbours</font></i> ← children of <i><font color="green">current</font></i><br/><br/>
        while min(<i><font color="orange">neighbours</font></i>) &lt; <i><font color="green">current</font></i> do
        <div style="padding-left:20px;">
<i><font color="green">current</font></i> ← min(<i><font color="orange">neighbours</font></i>)<br/>
<i><font color="orange">neighbours</font></i> ← children of <i><font color="green">current</font></i>
</div>
        return <i><font color="green">current</font></i>
</div>
</div>
<br/><br/><p>Here, we introduce a few new ideas.</p>
<p>First, we treat the route between two nodes as a function, the value of which is the distance between the two nodes.
Second, we generate “children” of this function.</p>
<hr class="docutils"/>
<div class="section" id="the-function">
<h3>The function<a class="headerlink" href="#the-function" title="Permalink to this headline">¶</a></h3>
<p>We need to define a function <span class="math notranslate nohighlight">\(f\)</span> that is our target for optimization. <br/><br/>
<span class="math notranslate nohighlight">\(f(x)\)</span> gives us the length of a route for some given route <span class="math notranslate nohighlight">\(x \in Y\)</span>, where <span class="math notranslate nohighlight">\(Y\)</span> is the set of all possible routes between two specific nodes.</p>
<p>How do we generate <span class="math notranslate nohighlight">\(x\)</span>? We could just generate random permutations between the two nodes, filtering for permutations that are feasible, and optimize <span class="math notranslate nohighlight">\(f\)</span> over these random, sparse permutations.</p>
<p>However, this method is not reproducible (because the permutations change every run).</p>
<p>Instead, we make a deterministic policy that generates a number of <span class="math notranslate nohighlight">\(x \in Y\)</span> by successively “failing” nodes between the source and destination nodes. We then find the shortest path between the nodes before and after the “failed” nodes.</p>
<p>By failing the nodes in a deterministic fashion, we can say that we have a function and neighbourhood with defined size for a certain value so we can “rigorously” conduct a local search.</p>
<p>To generate our initial route and children routes, we will use the <code class="docutils literal notranslate"><span class="pre">smart_mobility_utilities</span></code> package. You can see how these routes are generated by consulting the documentation for that package.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The implementation below uses a function called <code class="docutils literal notranslate"><span class="pre">get_children</span></code> which is located in the <code class="docutils literal notranslate"><span class="pre">smart_mobility_utilities.children</span></code> library. It offers both normal and multiprocessed versions in order to speed up processing time.</p>
<p>We will be using the multiprocessing version of the function, as it performs with approximately 80% processing time reduction.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Setup the Graph, origin, and destination</span>
<span class="kn">from</span> <span class="nn">smart_mobility_utilities.common</span> <span class="kn">import</span> <span class="n">Node</span>
<span class="kn">from</span> <span class="nn">smart_mobility_utilities.viz</span> <span class="kn">import</span> <span class="n">draw_route</span>

<span class="n">reference</span> <span class="o">=</span> <span class="p">(</span><span class="mf">43.661667</span><span class="p">,</span> <span class="o">-</span><span class="mf">79.395</span><span class="p">)</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">osmnx</span><span class="o">.</span><span class="n">graph_from_point</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">clean_periphery</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">origin</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">G</span><span class="p">,</span> <span class="n">osmid</span><span class="o">=</span><span class="mi">55808290</span><span class="p">)</span>
<span class="n">destination</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">G</span><span class="p">,</span> <span class="n">osmid</span><span class="o">=</span><span class="mi">389677909</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">smart_mobility_utilities.common</span> <span class="kn">import</span> <span class="n">randomized_search</span><span class="p">,</span> <span class="n">cost</span>
<span class="kn">from</span> <span class="nn">smart_mobility_utilities.children</span> <span class="kn">import</span> <span class="n">get_children</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Visualize the costs over time</span>
<span class="n">costs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1"># Set the number of children to generate</span>
<span class="n">num_children</span> <span class="o">=</span> <span class="mi">20</span>

<span class="n">current</span> <span class="o">=</span> <span class="n">randomized_search</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">origin</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span> <span class="n">destination</span><span class="o">.</span><span class="n">osmid</span><span class="p">)</span>
<span class="n">costs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">current</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Initial cost:"</span><span class="p">,</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">neighbours</span> <span class="o">=</span> <span class="n">get_children</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">current</span><span class="p">,</span><span class="n">num_children</span><span class="o">=</span><span class="n">num_children</span><span class="p">,</span> <span class="n">multiprocessing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="n">shortest</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">neighbours</span> <span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">route</span> <span class="p">:</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Initial min(children):"</span><span class="p">,</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">shortest</span><span class="p">))</span>
<span class="k">while</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">shortest</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">current</span><span class="p">):</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">shortest</span>
    <span class="n">neighbours</span> <span class="o">=</span> <span class="n">get_children</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">current</span><span class="p">,</span><span class="n">num_children</span><span class="o">=</span><span class="n">num_children</span><span class="p">,</span> <span class="n">multiprocessing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">shortest</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">neighbours</span> <span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">route</span> <span class="p">:</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">))</span>
    <span class="n">costs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">current</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Current cost:"</span><span class="p">,</span><span class="n">costs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="s2">"|"</span><span class="p">,</span><span class="s2">"min(children):"</span><span class="p">,</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">shortest</span><span class="p">))</span>

<span class="n">route</span> <span class="o">=</span> <span class="n">current</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">costs</span><span class="p">)))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Hill climbing: Shortest Path"</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">costs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Final cost:"</span><span class="p">,</span><span class="n">costs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Initial cost: 1076.887
Initial min(children): 1008.003
Current cost: 1008.003 | min(children): 801.464
Current cost: 801.464 | min(children): 801.947
Final cost: 801.464
</pre></div>
</div>
<img alt="../../_images/InformedSearch_22_1.png" src="../../_images/InformedSearch_22_1.png"/>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">draw_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">
{"version_major": 2, "version_minor": 0, "model_id": "5146368d91db4bf49d45cf63d6336ea9"}
</script></div>
</div>
<p>While the implementation above is deterministic in nature, the initial route is still randomized. That means that it’s possible to get different results across runs.</p>
<p>Hill climbing will generally return some decent results as there are few local optimal points in the route function. However, with larger search spaces that will naturally have more local maxima and plateaus, it will get stuck fairly quickly.</p>
</div>
</div>
<hr class="docutils"/>
<div class="section" id="beam-search">
<h2>Beam Search<a class="headerlink" href="#beam-search" title="Permalink to this headline">¶</a></h2>
<p>While Hill Climbing maintains a single “best” state throughout the run, beam search keeps <span class="math notranslate nohighlight">\(k\)</span> states in memory. At each iterations, it generates the neighbours for each of the <span class="math notranslate nohighlight">\(k\)</span> states, and puts them into a pool with the <span class="math notranslate nohighlight">\(k\)</span> states from the original beam. It then selects the best <span class="math notranslate nohighlight">\(k\)</span> routes from the pool to become the new beam, and this process repeats. The algorithm terminates when the new beam is equal to the old beam. As it is a local search algorithm, it is also susceptible to being stuck at local maxima.</p>
<p>A beam search with <span class="math notranslate nohighlight">\(k=\infty\)</span> is the same as a BFS. Because there is the risk that a state that would lead to the optimal solution might get discarded, beam searches are considered to be incomplete (it may not terminate with the solution).</p>
<style>
i {font-weight:normal}
span {font-weight:normal}
</style>
<div style="background-color: rgba(0,0,0,0.0470588);padding:10px;font-family:monospace;">
<b>BEAM-SEARCH</b>(<i>source</i>,<i>destination</i>,<i>k</i>) <b>return</b> a <i>route</i>
<div style="padding-left:20px;">
<i><font color="green">seen</font></i> ← <i>nil</i><br/>
<i><font color="orange">beam</font></i> ← random <i>k</i> routes from <i>source</i> to <i>destination</i><br/>
        add <i><font color="orange">beam</font></i> to <i><font color="green">seen</font></i><br/>
<i><font color="purple">pool</font></i> ← children of routes in the <i><font color="orange">beam</font></i> with consideration of <i><font color="green">seen</font></i> + <i><font color="orange">beam</font></i><br/>
<i><font color="grey">last_beam</font></i> ← <i>nil</i><br/><br/>
        while <i><font color="orange">beam</font></i> is not <i><font color="grey">last_beam</font></i> do
        <div style="padding-left:20px;">
<i><font color="grey">last_beam</font></i> ← <i><font color="orange">beam</font></i><br/>
<i><font color="orange">beam</font></i> ← the best <i>k</i> routes from <i><font color="purple">pool</font></i><br/>
            add <i><font color="orange">beam</font></i> to <i><font color="green">seen</font></i><br/>
<i><font color="purple">pool</font></i> ← children of routes in the <i><font color="orange">beam</font></i> with consideration of <i><font color="green">seen</font></i> + <i><font color="orange">beam</font></i>
</div>
<b>return</b> optimal <i>route</i> in <i><font color="orange">beam</font></i>
</div>
</div>
<br/><br/><div class="admonition note">
<p class="admonition-title">Note</p>
<p>The implementation below uses a function called <code class="docutils literal notranslate"><span class="pre">get_beam</span></code> which is located in the <code class="docutils literal notranslate"><span class="pre">smart_mobility_utilities.children</span></code> library. It offers both normal and multiprocessed versions in order to speed up processing time.</p>
<p>We will be using the multiprocessing version of the function, as it performs with approximately 50% processing time reduction.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">from</span> <span class="nn">smart_mobility_utilities.children</span> <span class="kn">import</span> <span class="n">get_beam</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Initialize</span>
<span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">num_neighbours</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">costs</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">beam</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomized_search</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">origin</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span><span class="n">destination</span><span class="o">.</span><span class="n">osmid</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>

<span class="c1"># the seen routes must be converted to a tuple to be hashable to be stored in a set</span>
<span class="k">for</span> <span class="n">route</span> <span class="ow">in</span> <span class="n">beam</span><span class="p">:</span> <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">route</span><span class="p">))</span>

<span class="n">pool</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">children</span> <span class="o">=</span> <span class="n">get_beam</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">beam</span><span class="p">,</span><span class="n">num_neighbours</span><span class="p">,</span><span class="n">multiprocessing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">workers</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="n">costs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">beam</span><span class="p">])</span>
<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">child</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">pool</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
<span class="n">pool</span> <span class="o">+=</span> <span class="n">beam</span>
<span class="n">last_beam</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">while</span> <span class="n">beam</span> <span class="o">!=</span> <span class="n">last_beam</span><span class="p">:</span>
    <span class="n">last_beam</span> <span class="o">=</span> <span class="n">beam</span>
    <span class="n">beam</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">route</span><span class="p">:</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">route</span> <span class="ow">in</span> <span class="n">beam</span><span class="p">:</span> <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">route</span><span class="p">))</span>    
    
    <span class="n">pool</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">get_beam</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">beam</span><span class="p">,</span><span class="n">num_neighbours</span><span class="p">,</span><span class="n">multiprocessing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">workers</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">costs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">beam</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">child</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">pool</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">);</span> <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
    <span class="n">pool</span> <span class="o">+=</span> <span class="n">beam</span>   
<span class="n">route</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">route</span> <span class="p">:</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">))</span> 


<span class="nb">print</span><span class="p">(</span><span class="s2">"Route:"</span><span class="p">,</span><span class="n">route</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Cost:"</span><span class="p">,</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">route</span><span class="p">))</span>

<span class="n">costs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">costs</span><span class="p">))</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">costs</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Beam Search: Costs vs time"</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Route: [55808290, 304891685, 55808284, 1252869817, 55808239, 389678268, 4953810915, 389678267, 24960090, 389678273, 24959523, 50885177, 389677947, 2143489692, 2480712846, 389678140, 389678139, 389678138, 3707407638, 6028561924, 5098988924, 389678131, 6028562356, 854322047, 389677908, 749952029, 389677909]
Cost: 801.464
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 1.0, 'Beam Search: Costs vs time')
</pre></div>
</div>
<img alt="../../_images/InformedSearch_28_2.png" src="../../_images/InformedSearch_28_2.png"/>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">draw_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">
{"version_major": 2, "version_minor": 0, "model_id": "4855abc8ce884d938d8e59f2fc19338b"}
</script></div>
</div>
</div>
<hr class="docutils"/>
<div class="section" id="a-search">
<h2>A* Search<a class="headerlink" href="#a-search" title="Permalink to this headline">¶</a></h2>
<p>A* (pronounced A-star) search is an informed search algorithm widely used in pathfinding and graph traversal.</p>
<p>A* works by “greedily” choosing which vertex to explore next, based on a function:</p>
<p><span class="math notranslate nohighlight">\(f(V) = h(V) + g(V)\)</span>, where <span class="math notranslate nohighlight">\(h\)</span> is a heuristic, and <span class="math notranslate nohighlight">\(g\)</span> is the cost accrued up to that point.</p>
<style>
i {font-weight:normal}
span {font-weight:normal}
</style>
<div style="background-color: rgba(0,0,0,0.0470588);padding:10px;font-family:monospace;">
<b>A* Heuristic</b> ← sum of straight-line distance between the node to source and node to destination<br/>
<b>PQ</b> ← min heap according to <b>A* Heuristic</b><br/><br/>
<b>A*-SEARCH</b>(<i>source</i>,<i>destination</i>) <b>return</b> a <i>route</i>
<div style="padding-left:20px;">
<i><font color="green">frontier</font></i> ← a <b>PQ</b> initialized with <i>source</i><br/>
<i><font color="grey">explored</font></i> ← <i>empty</i><br/>
<i><font color="orange">found</font></i> ← <i>False</i><br/>
        while <i><font color="green">frontier</font></i> is not <i>empty</i> and <i><font color="orange">found</font></i> is <i>False</i> do
        <div style="padding-left:20px;">
<i>node</i> ← <i><font color="green">frontier</font></i>.pop()<br/>
        add <i>node</i> to <i><font color="grey">explored</font></i><br/>
        for <i>child</i> in <i>node</i>.expand() do
            <div style="padding-left:20px;">
                if <i>child</i> is not in <i><font color="grey">explored</font></i> and <i>child</i> is not in <i><font color="green">frontier</font></i> then
                <div style="padding-left:20px;">
                if <i>child</i> is <i>destination</i> then
                    <div style="padding-left:20px;">
<i>route</i> ← <i>child</i>.route()<br/>
<i><font color="orange">found</font></i> ← <i>True</i>
</div>
                add <i>child</i> to <i><font color="green">frontier</font></i>
</div>
</div>
</div>
    return <i>route</i>
</div>
</div>
<br/><br/><div class="section" id="the-heuristic">
<h3>The Heuristic<a class="headerlink" href="#the-heuristic" title="Permalink to this headline">¶</a></h3>
<p>The driving force behind A* is the selection of a new vertex (or node) to explore based on the lowest heuristic value. This heuristic value is computed by the following formula:</p>
<p>let <span class="math notranslate nohighlight">\(dist(x,y)\)</span> be a function that calculates the straight line distance between two nodes <span class="math notranslate nohighlight">\(x,y\)</span>,<br/>
and let <span class="math notranslate nohighlight">\(O\)</span> be the origin node, and <span class="math notranslate nohighlight">\(D\)</span> be the destination node,</p>
<p><span class="math notranslate nohighlight">\(h(V) = dist(V,O) + dist(V,D)\)</span> for any given node <span class="math notranslate nohighlight">\(V\)</span></p>
<p>As the sum of the distance to the origin and destination is minimized when <span class="math notranslate nohighlight">\(V\)</span> lies on a straight line from <span class="math notranslate nohighlight">\(O\)</span> to <span class="math notranslate nohighlight">\(D\)</span>, this heuristic prioritizes nodes which are “closer” to the straight-line distance from origin to destination.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The implentation of the A* heuristic in <code class="docutils literal notranslate"><span class="pre">smart_mobility_utilities</span></code> defaults to calculating distances as if the Earth were flat. For local searches, this yields the best results. If the size of the search area is larger, it is better to calculate distance using the <code class="docutils literal notranslate"><span class="pre">haversine_distance</span></code>, which takes into account the curvature of the Earth.</p>
<p>This can be done by setting the distance function like so:<br/>
<code class="docutils literal notranslate"><span class="pre">astar_heuristic(G,origin.osmid,destination.osmid,</span> <span class="pre">measuring_dist</span> <span class="pre">=</span> <span class="pre">haversine_distance)</span></code></p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the A* Heuristic for all the nodes in the graph</span>
<span class="kn">from</span> <span class="nn">smart_mobility_utilities.problem</span> <span class="kn">import</span> <span class="n">astar_heuristic</span>

<span class="n">toOrigin</span><span class="p">,</span> <span class="n">toDestination</span> <span class="o">=</span> <span class="n">astar_heuristic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">origin</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span> <span class="n">destination</span><span class="o">.</span><span class="n">osmid</span><span class="p">)</span>

<span class="n">route</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">frontier</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

<span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
<span class="n">explored</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">while</span> <span class="n">frontier</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>    
    <span class="c1"># choose a node based on its heuristic value</span>
    <span class="n">node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">frontier</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">toOrigin</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span> <span class="o">+</span> <span class="n">toDestination</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">])</span>
    <span class="n">frontier</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="n">explored</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    
    <span class="c1"># expand its children</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">expand</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span> <span class="ow">and</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">frontier</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span>
                <span class="n">route</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">continue</span>
            <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"The route is "</span><span class="p">,</span><span class="n">route</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Route cost is"</span><span class="p">,</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">))</span>
<span class="n">draw_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The route is  [55808290, 304891685, 55808284, 1252869817, 55808239, 389678268, 4953810915, 389678267, 24960090, 389678273, 1258698113, 389678151, 389678142, 2143489694, 389678141, 2143488528, 389678140, 389678139, 389678138, 3707407638, 6028561924, 6028561921, 389678131, 6028562356, 854322047, 389677908, 749952029, 389677909]
Route cost is 839.904
</pre></div>
</div>
<script type="application/vnd.jupyter.widget-view+json">
{"version_major": 2, "version_minor": 0, "model_id": "ad72e8047e9249898a295eb0464dd697"}
</script></div>
</div>
</div>
</div>
<hr class="docutils"/>
<div class="section" id="bi-directional-search">
<h2>Bi-Directional Search<a class="headerlink" href="#bi-directional-search" title="Permalink to this headline">¶</a></h2>
<p>The purpose of bi-directional searches are to run two simultaneous, non-parallel searches; one starts at the origin and the other at the destination, with the goal of meeting somewhere in between.</p>
<p>This approach is more efficient because of the time complexities involved.</p>
<p>For example, a BFS search with a constant branching factor <span class="math notranslate nohighlight">\(b\)</span> and depth <span class="math notranslate nohighlight">\(d\)</span> would have an overall space complexity of <span class="math notranslate nohighlight">\(O(d^b)\)</span>. By running two BFS searches in opposite directions with only half the depth (<span class="math notranslate nohighlight">\(d/2\)</span>), the space complexity becomes instead <span class="math notranslate nohighlight">\(O((d/2)^b)+O((d/2)^b)\)</span>, which is much lower than the original <span class="math notranslate nohighlight">\(O(d^b)\)</span>.</p>
<style>
i {font-weight:normal}
span {font-weight:normal}
</style>
<div style="background-color: rgba(0,0,0,0.0470588);padding:10px;font-family:monospace;">
<b>BI-DIRECTIONAL-SEARCH</b>(<i>source</i>,<i>destination</i>) <b>return</b> a <i>route</i>
<div style="padding-left:20px;">
<font color="#03A9F4">// _f for forward, _b for backward</font><br/>
<i><font color="green">frontier_f</font></i> ← initialized with <i>source</i><br/>
<i><font color="green">frontier_b</font></i> ← initialized with <i>destination</i><br/>
<i><font color="grey">explored_f</font></i> ← <i>empty</i><br/>
<i><font color="grey">explored_b</font></i> ← <i>empty</i><br/>
<i><font color="orange">found</font></i> ← <i>False</i><br/>
<i><font color="purple">collide</font></i> ← <i>False</i> <font color="#03A9F4">// if front overlaps with back</font><br/>
<i><font color="blue">found</font></i> ← <i>False</i><br/>
<i><font color="blue">altr_expand</font></i> ← <i>False</i><font color="#03A9F4">// expansion direction</font><br/><br/>
        while <i><font color="green">frontier_f</font></i> is not <i>empty</i> and <i><font color="green">frontier_b</font></i> is not <i>empty</i> and not <i><font color="purple">collide</font></i> and not <i><font color="orange">found</font></i> do
        <div style="padding-left:20px;">
            if <i><font color="blue">altr_expand</font></i> then
            <div style="padding-left:20px;">
<i>node</i> ← <i><font color="green">frontier_f</font></i>.pop()<br/>
                add <i>node</i> to <i><font color="grey">explored_f</font></i><br/>
                for <i>child</i> in <i>node</i>.expand() do
                <div style="padding-left:20px;">
                    if <i>child</i> in <i><font color="grey">explored_f</font></i> then continue<br/>
                    if <i>child</i> is <i>destination</i> then
                        <div style="padding-left:20px;">
<i>route</i> ← <i>child</i>.route()<br/>
<i><font color="orange">found</font></i> ← <i>True</i>
</div>
                    if <i>child</i> in <i><font color="grey">explored_b</font></i> then
                        <div style="padding-left:20px;">
<i>route</i> ← <i>child</i>.route() + reverse(<i>overlapped</i>.route())<br/>
<i><font color="purple">collide</font></i> ← <i>True</i>
</div>
                    add <i>child</i> to <i><font color="green">frontier_f</font></i><br/>
<i><font color="blue">altr_expand</font></i> ← not <i><font color="blue">altr_expand</font></i>
</div>
</div>
            else
            <div style="padding-left:20px;">
<i>node</i> ← <i><font color="green">frontier_b</font></i>.pop()<br/>
                add <i>node</i> to <i><font color="grey">explored_b</font></i><br/>
                for <i>child</i> in <i>node</i>.expand() do
                <div style="padding-left:20px;">
                    if <i>child</i> in <i><font color="grey">explored_b</font></i> then continue<br/>
                    if <i>child</i> is <i>origin</i> then
                        <div style="padding-left:20px;">
<i>route</i> ← <i>child</i>.route()<br/>
<i><font color="orange">found</font></i> ← <i>True</i>
</div>
                    if <i>child</i> in <i><font color="grey">explored_f</font></i> then
                        <div style="padding-left:20px;">
<i>route</i> ← reverse(<i>child</i>.route()) + <i>overlapped</i>.route()<br/>
<i><font color="purple">collide</font></i> ← <i>True</i>
</div>
                    add <i>child</i> to <i><font color="green">frontier_b</font></i><br/>
<i><font color="blue">altr_expand</font></i> ← not <i><font color="blue">altr_expand</font></i>
</div>
</div>
</div>
        return <i>route</i>
</div>
</div>
<br/><br/><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Using A* as search heuristic and algorithm</span>

<span class="c1"># define destination and origin for the backwards expansion</span>
<span class="n">destination_b</span> <span class="o">=</span> <span class="n">origin</span>
<span class="n">origin_b</span> <span class="o">=</span> <span class="n">destination</span>

<span class="c1"># get A*</span>
<span class="n">toOrigin_f</span><span class="p">,</span> <span class="n">toDestination_f</span> <span class="o">=</span> <span class="n">astar_heuristic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">origin</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span> <span class="n">destination</span><span class="o">.</span><span class="n">osmid</span><span class="p">)</span>
<span class="n">toOrigin_b</span><span class="p">,</span> <span class="n">toDestination_b</span> <span class="o">=</span> <span class="n">astar_heuristic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">origin_b</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span> <span class="n">destination_b</span><span class="o">.</span><span class="n">osmid</span><span class="p">)</span>

<span class="n">route</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">f_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">toOrigin_f</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span> <span class="o">+</span> <span class="n">toDestination_f</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span>
<span class="n">b_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">toOrigin_b</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span> <span class="o">+</span> <span class="n">toDestination_b</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span>

<span class="n">frontier_f</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">frontier_b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

<span class="n">frontier_f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
<span class="n">frontier_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">origin_b</span><span class="p">)</span>

<span class="n">explored_f</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">explored_b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

<span class="n">collide</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">altr_expand</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># to alternate between front and back</span>

<span class="k">while</span> <span class="n">frontier_f</span> <span class="ow">and</span> <span class="n">frontier_b</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">collide</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
   
    <span class="k">if</span> <span class="n">altr_expand</span><span class="p">:</span>
        <span class="c1"># remove node_f from frontier_f to expand it</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">frontier_f</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">f_value</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        <span class="n">frontier_f</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">explored_f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">expand</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">explored_f</span><span class="p">:</span> <span class="k">continue</span>
            
            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span>
                <span class="n">route</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="c1"># checking for collusion with the target expansion</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">explored_b</span><span class="p">:</span>
                <span class="n">overlapped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">explored_b</span> <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">child</span><span class="p">))</span>
                <span class="c1"># we don't take the overlapped node twice</span>
                <span class="n">route</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">overlapped</span><span class="o">.</span><span class="n">path</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">collide</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="n">frontier_f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">altr_expand</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># remove node_b from frontier_b to expand it</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">frontier_b</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">b_value</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        <span class="n">frontier_b</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">explored_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">expand</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">explored_b</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">destination_b</span><span class="p">:</span>
                <span class="n">route</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># we reverse the list because we expand from the back</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">explored_f</span><span class="p">:</span>
                <span class="n">overlapped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">explored_f</span> <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">child</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">route</span> <span class="o">=</span> <span class="n">overlapped</span><span class="o">.</span><span class="n">path</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">collide</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="n">frontier_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">altr_expand</span> <span class="o">=</span> <span class="kc">True</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"The route is </span><span class="se">\n\n</span><span class="s2">"</span><span class="p">,</span><span class="n">route</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Cost of the route:"</span><span class="p">,</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">route</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The route is 

 [55808290, 304891685, 55808284, 1252869817, 55808239, 389678268, 4953810915, 389678267, 24960090, 389678273, 1258698113, 389678151, 389678142, 2143489694, 389678141, 2143488528, 389678140, 249991437, 3707407641, 24960080, 6028561924, 6028561921, 389678131, 6028562356, 854322047, 389677908, 749952029, 389677909]
</pre></div>
</div>
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">KeyError</span><span class="g g-Whitespace">                                  </span>Traceback (most recent call last)
<span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">ipykernel_4647</span><span class="o">/</span><span class="mf">2143057713.</span><span class="n">py</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">     </span><span class="mi">76</span> 
<span class="g g-Whitespace">     </span><span class="mi">77</span> <span class="nb">print</span><span class="p">(</span><span class="s2">"The route is </span><span class="se">\n\n</span><span class="s2">"</span><span class="p">,</span><span class="n">route</span><span class="p">)</span>
<span class="ne">---&gt; </span><span class="mi">78</span> <span class="nb">print</span><span class="p">(</span><span class="s2">"Cost of the route:"</span><span class="p">,</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">route</span><span class="p">))</span>

<span class="nn">~/book-env/smart_mobility_utilities/smart_mobility_utilities/common.py</span> in <span class="ni">cost</span><span class="nt">(G, route)</span>
<span class="g g-Whitespace">     </span><span class="mi">71</span>     <span class="n">weight</span> <span class="o">=</span> <span class="mi">0</span>
<span class="g g-Whitespace">     </span><span class="mi">72</span>     <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">route</span><span class="p">,</span> <span class="n">route</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
<span class="ne">---&gt; </span><span class="mi">73</span>         <span class="n">weight</span> <span class="o">+=</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">'length'</span><span class="p">]</span>
<span class="g g-Whitespace">     </span><span class="mi">74</span>     <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">75</span> 

<span class="nn">~/book-env/lib/python3.8/site-packages/networkx/classes/coreviews.py</span> in <span class="ni">__getitem__</span><span class="nt">(self, name)</span>
<span class="g g-Whitespace">     </span><span class="mi">80</span> 
<span class="g g-Whitespace">     </span><span class="mi">81</span>     <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="ne">---&gt; </span><span class="mi">82</span>         <span class="k">return</span> <span class="n">AtlasView</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atlas</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
<span class="g g-Whitespace">     </span><span class="mi">83</span> 
<span class="g g-Whitespace">     </span><span class="mi">84</span>     <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

<span class="ne">KeyError</span>: 3707407641
</pre></div>
</div>
</div>
</div>
<p>Why is there a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code> in the above code? That’s because our bi-directional implementation assumes that for every edge <span class="math notranslate nohighlight">\(u,v\)</span>, there exists an edge <span class="math notranslate nohighlight">\(v,u\)</span>, but this is not the case in reality. For example, some streets may be unidirectional (i.e. one-way streets) or have turning restrictions. In our case, there is no edge that connects <code class="docutils literal notranslate"><span class="pre">2143489694</span></code> to <code class="docutils literal notranslate"><span class="pre">389678141</span></code>, but an edge does exist in the reverse direction.</p>
<p>How can we fix this? If we assume that we are routing for the purpose of pedestrian transit, unidirectional edges essentially act as bidirectional edges and there is no real issue. We then simple need to calculate the route cost from the origin to the node before the offending node, and add the cost from the destination to the node before the offending node, as below. For more complicated routing problems involving vehicles, we can then implement various methods to avoid unidirectional edges for the reverse path (from destination to origin) that would avoid this problem entirely.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">route_cost</span> <span class="o">=</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">route</span><span class="p">[:</span><span class="mi">17</span><span class="p">])</span>
<span class="n">second_half</span> <span class="o">=</span> <span class="n">route</span><span class="p">[</span><span class="mi">17</span><span class="p">:]</span>
<span class="n">second_half</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="n">route_cost</span> <span class="o">+=</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">second_half</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Cost of the route:"</span><span class="p">,</span><span class="n">route_cost</span><span class="p">)</span>
<span class="n">draw_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cost of the route: 827.505
</pre></div>
</div>
<script type="application/vnd.jupyter.widget-view+json">
{"version_major": 2, "version_minor": 0, "model_id": "8641653bf8184b6084c5f60b91195bfa"}
</script></div>
</div>
</div>
<hr class="docutils"/>
<div class="section" id="hierarchical-approaches">
<h2>Hierarchical Approaches<a class="headerlink" href="#hierarchical-approaches" title="Permalink to this headline">¶</a></h2>
<p>When facing routing problems at larger scales, such as those involving entire continents or graphs with millions of nodes, it is simply implausible to use basic approaches like Dijkstra or DFS. Instead, routing algorithms “prune” the search space in order to simplify the routing problem. Additionally, routing services may choose to precompute certain routes and cache them on servers, so that response times to user queries are reasonable.</p>
<p>Hierarchical search algorithms prune the search space by generating admissible heuristics that abstract the search space. Read more about the general approach of hierarchical methods at <a class="reference external" href="https://www.aaai.org/ocs/index.php/SOCS/SOCS11/paper/viewFile/4035/4363">Faster Optimal and Suboptimal Hierarchical Search</a>.</p>
<p>In this section, we’ll give a brief overview of two hierarchical approaches that aim to solve the shortest path problem, and show how their heuristics are computed. There will also be a <code class="docutils literal notranslate"><span class="pre">python</span></code> implementation of the Contraction Hierarchies example.</p>
<hr class="docutils"/>
<div class="section" id="highway-hierarchies">
<h3>Highway Hierarchies<a class="headerlink" href="#highway-hierarchies" title="Permalink to this headline">¶</a></h3>
<p>In this algorithm, the hierarchy “level” of each road/arc in the graph is calculated. This distinguishes the type of road segment (i.e. residential, national roads, highways). This is further supplemented by relevant data such as maximum designated driving speed, as well as number of turns in the road. After the heuristics are generated for the graph, the data is passed through a modified search function (bi-directional Dijkstra, A*, etc) that considers the distance to the destination and the potential expansion node class.</p>
<p>For example, the algorithm will generally consider highways as viable expansion nodes when it is still relatively further away from the target, and then will start to include national roads, and finally residential streets as it nears the destination.</p>
<p>While this approach “makes sense”, there are some disadvantages. First, the algorithm largely overlooks what kind of roads humans “prefer” to drive on. That is to say, which a highway might make sense for a given route, the user may “prefer” to take local roads (i.e. driving to a friend’s house who lives nearby). Secondly, highway hierarchies do not take into account factors such as traffic, which fluctuates often and adds significant cost to an “optimal” route.</p>
<p>You can learn more about contraction hierarchies <a class="reference external" href="https://link.springer.com/chapter/10.1007/11561071_51">here</a>.</p>
</div>
<hr class="docutils"/>
<div class="section" id="contraction-hierarchies">
<h3>Contraction Hierarchies<a class="headerlink" href="#contraction-hierarchies" title="Permalink to this headline">¶</a></h3>
<p>While the highway hierarchies algorithm may be useful for speeding up shortest path searches, it only considers three levels of road hierarchies. On the other hand, the contraction hierarchies algorithm introduced by <a class="reference external" href="https://link.springer.com/chapter/10.1007/978-3-540-68552-4_24">Contraction Hierarchies: Faster and Simpler Hierarchical Routing in Road Networks</a> has the same number of hierarchies as nodes in the graph, which is beneficial as increased number of hierarchies results in more pruning of the search space.</p>
<div class="section" id="contraction">
<h4>Contraction<a class="headerlink" href="#contraction" title="Permalink to this headline">¶</a></h4>
<p>Taking any node <span class="math notranslate nohighlight">\(V\)</span> from a graph <span class="math notranslate nohighlight">\(G\)</span>, remove <span class="math notranslate nohighlight">\(V\)</span> as well as any connected edges. <br/>
Add any number of edges to <span class="math notranslate nohighlight">\(G\)</span> such that the shortest distance for any pair of neighbouring nodes remains the same, even after <span class="math notranslate nohighlight">\(V\)</span> has been removed. Below is an example:<br/>
<img alt="" src="../../_images/uncontract.png"/></p>
<p>Suppose we are contracting <strong>Node 1</strong>. By removing the node, we have now changed the shortest path for 0→2, 0→3, and 2→3. We can restore it by creating new edges. After the creation of new edges, we then reinsert any removed nodes and edges. We then update that node with its hierarchy level (which is just the order of contraction, from <span class="math notranslate nohighlight">\(1 to n\)</span>). See the below updated graph:<br/><br/>
<img alt="" src="../../_images/contract.png"/></p>
<p>This process is then repeated for all the other nodes. In our example, no other nodes need to be contracted, as removing any one of the remaining nodes does not affect the rest of the graph in terms of shortest path. This process will form <strong>shortcuts</strong>, which allow us to search the graph much faster, as we can ignore certain nodes that have been “pruned”.</p>
</div>
<div class="section" id="contraction-order">
<h4>Contraction Order<a class="headerlink" href="#contraction-order" title="Permalink to this headline">¶</a></h4>
<p>Any order for node contraction will result in a successful algorithm, however some contraction ordering systems minimizes the number of new edges added to the graph, and thus the overall running time.</p>
<p>To utilize this, we can employ the idea of <strong>edge difference (ED)</strong>. The ED of a node is <span class="math notranslate nohighlight">\(S-E\)</span>, where <span class="math notranslate nohighlight">\(S\)</span> is the number of new edges added if that node were to be contracted, and <span class="math notranslate nohighlight">\(E\)</span> is the number of edges that would be deleted. Minimizing ED is equivalent to minimizing the number of new edges added to the graph, and thus improves processing time.</p>
</div>
</div>
<hr class="docutils"/>
<div class="section" id="example-1-bi-directional-dijkstra-with-contraction">
<h3>Example #1: Bi-directional Dijkstra with contraction<a class="headerlink" href="#example-1-bi-directional-dijkstra-with-contraction" title="Permalink to this headline">¶</a></h3>
<p>After contracting a graph, we can run a bi-directional Dijkstra to compute all the shortest paths in the graph. Following this, any queries for the shortest path between any two nodes in the graph can be solved using a cached result.</p>
<p>There are some restrictions for our modified Dijkstra’s:</p>
<ol class="simple">
<li><p>The forward expansion only considers arcs <span class="math notranslate nohighlight">\(u,v\)</span>, where <span class="math notranslate nohighlight">\(level(u) &gt; level(v)\)</span>. This forms the <strong>upward graph</strong>, where only nodes with a higher contraction order can be relaxed.</p></li>
<li><p>The backward expansion only considers arcs <span class="math notranslate nohighlight">\(u,v\)</span>, where <span class="math notranslate nohighlight">\(level(u) &lt; level(v)\)</span>. This forms the <strong>downward graph</strong>, where only nodes with a lower contraction order can be relaxed.</p></li>
</ol>
<p>These restrictions help “prune” the search space and speed up the processing.</p>
<p>At the end, multiple paths are returned from source to destination, of which the shortest is selected to be the solution.</p>
<p>Let’s try this with the sample graph below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

<span class="c1"># Computing each contraction level requires a new graph, which is costly in terms of memory.</span>
<span class="c1"># To avoid this, we use a flag on every node to show its contraction state.</span>

<span class="c1"># Add 14 nodes</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">):</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">contracted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Define the edges</span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">4</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">5</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">2</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">2</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">2</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">5</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">7</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">4</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">6</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">13</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">5</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">4</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">4</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">2</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">1</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">13</span><span class="p">,{</span><span class="s1">'weight'</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="p">]</span>
<span class="c1"># Add the edges to the graph and visualize it.</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([</span><span class="o">*</span><span class="n">edges</span><span class="p">])</span>
<span class="n">networkx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/InformedSearch_43_0.svg" src="../../_images/InformedSearch_43_0.svg"/></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For this implementation we will be using two helper functions from <code class="docutils literal notranslate"><span class="pre">smart_mobility_utilities.contraction</span></code>.</p>
<p>The first is <code class="docutils literal notranslate"><span class="pre">dijkstra_with_contraction</span></code>, which simple runs a Dijkstra search on a graph, with the condition that the expansion nodes cannot be already contracted.</p>
<p>The second is <code class="docutils literal notranslate"><span class="pre">calculate_edge_difference</span></code>, which calculates the ED for every node in a given graph.</p>
<p>See the API docs for <code class="docutils literal notranslate"><span class="pre">smart_mobility_utilities.contraction</span></code> for more details.</p>
</div>
<p>We will first need to obtain the ED for the input graph:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">smart_mobility_utilities.contraction</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">shortest_paths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
    <span class="n">shortest_paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">shortest_paths</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dijkstra_with_contraction</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

<span class="n">edge_difference</span> <span class="o">=</span> <span class="n">calculate_edge_difference</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">shortest_paths</span><span class="p">)</span>
<span class="n">edge_difference</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">edge_difference</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(8, -5),
 (10, -4),
 (5, -3),
 (7, -3),
 (11, -3),
 (14, 0),
 (2, 2),
 (1, 3),
 (6, 4),
 (13, 5),
 (4, 7),
 (12, 18),
 (3, 26),
 (9, 33)]
</pre></div>
</div>
</div>
</div>
<p>While this is a good start to optimizing the node contraction order, it is by no means perfect. Notice that the ED values calculated above assume the node is the only node removed from the graph. Because we are successively removing every node in the graph, the ED list will potentially become inaccurate after even the first contraction.</p>
<p>Recall however that any arbitrary contraction order results in a successful algorithm. While there are ED heuristics that are able to update the ED list after each contraction, each of them come with their own costs and benefits.</p>
<p>For the purposes of this example, our ED list will be sufficient.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># to keep track of the edges added after the algorithm finishes</span>
<span class="n">edges_before</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>

<span class="n">current_graph</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>

<span class="k">for</span> <span class="n">node_ED</span> <span class="ow">in</span> <span class="n">edge_difference</span><span class="p">:</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">node_ED</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># now we will contract the given node through all iterations</span>
    <span class="n">networkx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span> <span class="s1">'contracted'</span><span class="p">)</span>
    
    <span class="n">new_graph</span> <span class="o">=</span> <span class="n">current_graph</span>
    <span class="n">new_graph</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="n">current_shortest_paths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">new_graph</span><span class="p">:</span>
            <span class="n">current_shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">new_graph</span><span class="p">:</span>
                <span class="n">current_shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="n">destination</span><span class="p">]</span> <span class="o">=</span> <span class="n">dijkstra_with_contraction</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
                
    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">current_shortest_paths</span><span class="p">:</span>
        <span class="n">SP_contracted</span> <span class="o">=</span> <span class="n">current_shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="n">SP_original</span> <span class="o">=</span> <span class="n">shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">SP_contracted</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">SP_contracted</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span> <span class="o">!=</span> <span class="n">SP_original</span><span class="p">[</span><span class="n">destination</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">"Added edge between "</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span><span class="s2">" after contracting"</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">SP_original</span><span class="p">[</span><span class="n">destination</span><span class="p">])</span>
                
    <span class="n">current_graph</span> <span class="o">=</span> <span class="n">new_graph</span>

<span class="c1"># new edges after adding additional arcs</span>
<span class="n">edges_after</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"# edges before"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_before</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"# edges after"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_after</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Added edge between  1 13  after contracting 14
Added edge between  2 13  after contracting 14
Added edge between  13 1  after contracting 14
Added edge between  13 2  after contracting 14
Added edge between  1 4  after contracting 2
Added edge between  4 1  after contracting 2
# edges before 26
# edges after 29
</pre></div>
</div>
</div>
</div>
<p>While it may seem like edges are being added twice, this is a simple graph, so adding an edge <code class="docutils literal notranslate"><span class="pre">(b,a)</span></code> when there is already an edge <code class="docutils literal notranslate"><span class="pre">(a,b)</span></code> has no effect.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Visualize the newly created "shortcute" on the graph</span>

<span class="n">added_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">edges_after</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">edges_before</span><span class="p">))</span>

<span class="c1"># let's color these edges and draw the graph again</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'r'</span> <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">added_edges</span> <span class="k">else</span> <span class="s1">'k'</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
<span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">added_edges</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
<span class="n">networkx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="n">widths</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">colors</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/InformedSearch_49_0.svg" src="../../_images/InformedSearch_49_0.svg"/></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Reformat ED list to hierarchy for search purposes</span>
<span class="n">hierarchical_order</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="k">for</span> <span class="n">order</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edge_difference</span><span class="p">):</span>
    <span class="n">hierarchical_order</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">order</span>
    
<span class="n">hierarchical_order</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{8: 0,
 10: 1,
 5: 2,
 7: 3,
 11: 4,
 14: 5,
 2: 6,
 1: 7,
 6: 8,
 13: 9,
 4: 10,
 12: 11,
 3: 12,
 9: 13}
</pre></div>
</div>
</div>
</div>
<p>Let’s now find the shortest path from <span class="math notranslate nohighlight">\(8\)</span> to <span class="math notranslate nohighlight">\(12\)</span>, using Dijkstra’s with contraction hierarchy.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">source</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">destination</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generating the upward graph</span>

<span class="c1"># initializing </span>
<span class="n">SP_s</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">parent_s</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">unrelaxed_s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
    <span class="n">SP_s</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">parent_s</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">unrelaxed_s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="n">SP_s</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># dijkstra</span>
<span class="k">while</span> <span class="n">unrelaxed_s</span><span class="p">:</span>
    <span class="n">node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">unrelaxed_s</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
    <span class="n">unrelaxed_s</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span> <span class="k">break</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
        <span class="c1"># skip unqualified edges</span>
        <span class="k">if</span> <span class="n">hierarchical_order</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">hierarchical_order</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span> <span class="k">continue</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">child</span><span class="p">][</span><span class="s1">'weight'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">child</span><span class="p">]:</span>
            <span class="n">SP_s</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
            <span class="n">parent_s</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generating the downward graph</span>

<span class="c1"># initializing </span>
<span class="n">SP_t</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">parent_t</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">unrelaxed_t</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
    <span class="n">SP_t</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">parent_t</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">unrelaxed_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="n">SP_t</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># dijkstra</span>
<span class="k">while</span> <span class="n">unrelaxed_t</span><span class="p">:</span>
    <span class="n">node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">unrelaxed_t</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
    <span class="n">unrelaxed_t</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span> <span class="k">break</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
        <span class="c1"># skip unqualified edges</span>
        <span class="k">if</span> <span class="n">hierarchical_order</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">hierarchical_order</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span> <span class="k">continue</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">child</span><span class="p">][</span><span class="s1">'weight'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">child</span><span class="p">]:</span>
            <span class="n">SP_t</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
            <span class="n">parent_t</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
</pre></div>
</div>
</div>
</div>
<p>With these, we now merge the common settled nodes from <code class="docutils literal notranslate"><span class="pre">SP_d</span></code> and <code class="docutils literal notranslate"><span class="pre">SP_s</span></code>, and find the minimum sum of values, This is our shortest path: the collision between the forward and backward expansions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">minimum</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
<span class="n">merge_node</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">SP_s</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span> <span class="k">continue</span>
    <span class="k">if</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minimum</span><span class="p">:</span>
        <span class="n">minimum</span> <span class="o">=</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">merge_node</span> <span class="o">=</span> <span class="n">i</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Minimum:"</span><span class="p">,</span><span class="n">minimum</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Merge node:"</span><span class="p">,</span><span class="n">merge_node</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Minimum: 3
Merge node: 9
</pre></div>
</div>
</div>
</div>
<p>Let’s compare this to <code class="docutils literal notranslate"><span class="pre">networkx</span></code>’s built in solver:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">networkx.algorithms.shortest_paths.weighted</span> <span class="kn">import</span> <span class="n">single_source_dijkstra</span>
<span class="n">single_source_dijkstra</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="pruning">
<h4>Pruning<a class="headerlink" href="#pruning" title="Permalink to this headline">¶</a></h4>
<p>We can actually check to see how many nodes were “pruned” from our graph, using the upward and downward graphs generated earlier.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">unvisited</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">s_node</span><span class="p">,</span> <span class="n">s_dist</span> <span class="ow">in</span> <span class="n">SP_s</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">t_node</span><span class="p">,</span> <span class="n">t_dist</span> <span class="ow">in</span> <span class="n">SP_t</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">s_node</span> <span class="o">==</span> <span class="n">t_node</span> <span class="ow">and</span> <span class="n">s_dist</span> <span class="o">==</span> <span class="n">t_dist</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="n">unvisited</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"""Skipped </span><span class="si">{</span><span class="n">unvisited</span><span class="si">}</span><span class="s2"> nodes from a graph with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="si">}</span><span class="s2"> total nodes,</span>
<span class="s2">resulting in pruning </span><span class="si">{</span><span class="n">unvisited</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s2">% of the nodes in our search space."""</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Skipped 7 nodes from a graph with 14 total nodes,
resulting in pruning 50.0% of the nodes in our search space.
</pre></div>
</div>
</div>
</div>
</div>
</div>
<hr class="docutils"/>
<div class="section" id="example-2-equestrian-statue-to-bahen-centre-using-contraction-hierarchy">
<h3>Example #2: Equestrian Statue to Bahen Centre using Contraction Hierarchy<a class="headerlink" href="#example-2-equestrian-statue-to-bahen-centre-using-contraction-hierarchy" title="Permalink to this headline">¶</a></h3>
<p>We can also use the same method to calculate the shortest path between our statue and lecture hall.</p>
<p>Contraction hierarchies typically require incredibly powerful processing resources to run, especially when dealing with larger scales. Our ED function runs in <span class="math notranslate nohighlight">\(O(n^2)\)</span> time, so for a graph of size 1,189 (our University of Toronto map), this requires 1,413,721 runs of <code class="docutils literal notranslate"><span class="pre">dijkstra_with_contraction</span></code>, which itself takes ~0.1 s per call. This would mean just calculating the ED would take 39 hours!</p>
<p>For this example, we’ve leveraged the use of some HPC (High-performance computing) resources to be able to generate the ED list in a more reasonable amount of time.</p>
<p>@TODO Here</p>
</div>
</div>
</div>
<script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./content/GraphSearchAlgorithms"
        },
        predefinedOutput: true
    }
    </script>
<script>kernelName = 'python3'</script>
</div>
<div class="prev-next-bottom">
<a class="left-prev" href="BlindSearch.html" id="prev-link" title="previous page">Blind Search Algorithms</a>
<a class="right-next" href="SearchComparison.html" id="next-link" title="next page">Search Algorithm Comparison</a>
</div>
</div>
</div>
<footer class="footer mt-5 mt-md-0">
<div class="container">
<p>
        
          By Alaa Khamis and Yinan Wang<br/>
        
            © Copyright 2021, Alaa Khamis and Yinan Wang.<br/>
</p>
</div>
</footer>
</main>
</div>
</div>
<script src="../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>
</body>
</html>